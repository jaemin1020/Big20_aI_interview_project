[
    {
        "질문": "딥러닝이란 무엇인가요?",
        "답변": "머신러닝의 한 종류로 인공신경망을 기반으로 데이터에서 패턴을 학습하여 새로운 데이터에 대한 예측을 하는 알고리즘 입니다."
    },
    {
        "질문": "딥러닝과 머신러닝의 차이를 설명해주시겠습니까?",
        "답변": "딥러닝은 모델이 특징 추출, 학습을 자동으로 수행합니다. 머신러닝은 사람이 특징을 설계하고 모델은 학습만 합니다."
    },
    {
        "질문": "오버피팅과 언더피팅의 차이점은 무엇인가요?",
        "답변": "오버피팅은 학습 데이터를 외우는 것처럼 과하게 학습하여 일반화 성능이 낮습니다. 기술적으로 설명하면 특정 뉴런에 대한 의존도가 매우 높은 상태 입니다. 언더피팅은 아직 학습 데이터의 패턴을 제대로 학습하지 못한 상태입니다."
    },
    {
        "질문": "FC layer와 CNN layer의 차이점을 설명해주시겠습니까?",
        "답변": "FC layer는 모든 뉴런이 연결되어 있고 입력 데이터를 고차원 공간에서 다른 차원으로 변환합니다. CNN layer는 필터를 사용해서 주변 데이터와의 관계와 지역적 패턴을 추출합니다."
    },
    {
        "질문": "비선형이란 무엇이고 왜 필요한가",
        "답변": "비선형은 직선 즉 선형 함수로 설명할 수 없는 복잡한 관계를 뜻합니다. 어려운 문제들은 비선형성을 추가해 복잡한 패턴을 학습해야 해결할 수 있습니다."
    },
    {
        "질문": "sigmoid 대신 relu를 사용하는 이유를 설명해주시겠습니까?",
        "답변": "sigmoid는 S자 형태로 음수에서 0에 가까워지고 양수에서 1에 가까워집니다. relu는 음수에서 0이고 양수에서 입력값 그대로를 출력합니다. sigmoid는 상대적으로 gradient vanishing 문제에 더 취약합니다. relu의 경우 출력 값의 상단 제한이 없지만 sigmoid의 경우 출력값이 0과 1 사이로 제한되기 때문에 기울기가 매우 작아지는 gradient vanishing 문제를 초래합니다."
    },
    {
        "질문": "relu가 곡선 함수를 근사하는 방법을 설명해주시겠습니까?",
        "답변": "relu는 여러 뉴런의 활성화 상태를 조합해 복잡한 비선형 함수를 근사할 수 있습니다. 각 뉴런의 활성화 여부를 on/off하면 곡선 함수를 근사할 수 있습니다."
    },
    {
        "질문": "gradient vanishing의 근본적인 원인을 설명해주시겠습니까?",
        "답변": "활성화 함수의 영향, 체인룰의 영향 두가지가 있습니다. 시그모이드의 경우 활성화 함수의 기울기가 0에 가까워져 결국 가중치를 업데이트하지 못합니다. 이를 방지하기 위해 relu를 사용하더라도 기울기가 0인 구간이 여전히 존재하기 때문에 chain rule에 의해 역전파 과정에서 낮은 층까지 도달하면 기울기가 0에 급격하게 가까워져 업데이트가 되지 않는 문제가 있습니다."
    },
    {
        "질문": "gradient descent의 개념을 설명해주시겠습니까?",
        "답변": "손실함수를 최소화하기 위해 가중치를 반복 업데이트하는 최적화 알고리즘입니다. 손실함수가 가장 작은 지점이 최적값 즉 해인데, n차 함수 형태인 손실함수의 최솟값을 구하는 방법은 미분해서 0인 지점으로 다가가는 것입니다. 여기서 미분이 gradient, 0으로 다가가는 것이 descent 입니다."
    },
    {
        "질문": "경사하강법 그래프의 x축과 y축의 의미를 설명해주시겠습니까?",
        "답변": "x축은 모델의 가중치, y축은 loss value를 뜻합니다."
    },
    {
        "질문": "GD 중에 때때로 loss가 증가하는 이유를 설명해주시겠습니까?",
        "답변": "첫번째로 learning rate가 너무 크면 한번의 업데이트에서 minima를 지나칠 수 있습니다. 두번째로 미니 배치 간의 분포 차이로 인한 변동성이 있을 수 있습니다. 세번째로 loss function의 landscape가 복잡해 local minima를 탈출할 때 발생할 수 있습니다."
    },
    {
        "질문": "GD와 SGD의 차이를 설명해주시겠습니까?",
        "답변": "GD는 전체 데이터셋을 모두 사용하여 느리지만 안정적으로 학습합니다. SGD는 데이터셋의 일부를 사용하여 빠르게 학습하지만 불안정할 수 있습니다."
    },
    {
        "질문": "RMSprop과 Adam에 대하여 설명해주시겠습니까?",
        "답변": "RMSprop은 기울기의 제곱에 대한 지수이동평균을 이용해 학습률을 동적으로 조절하는 방법입니다. 기울기가 큰 파라미터의 학습률을 줄여 더 안정적으로 학습을 진행합니다. Adam은 여기에 모멘텀을 추가하여 더 빠르고 효율적으로 학습하는 방법입니다."
    },
    {
        "질문": "모멘텀을 수식으로 설명해주시겠습니까?",
        "답변": "물리학적 관점의 관성을 알고리즘화한 것입니다. 기존 가중치에 속도인 모멘텀을 더해줍니다. 이번 단계의 속도는 이전 단계의 속도와 이번 단계의 기울기를 조합해 계산합니다."
    },
    {
        "질문": "backpropagation에 대하여 설명해주시겠습니까?",
        "답변": "입력에서 출력 방향인 순방향을 계산해 예측값을 구하고 loss를 구합니다. loss를 출력에서 입력 방향으로 전파하며 가중치를 얼마나 바꿔야 오차가 줄어드는지 계산합니다. 이것은 chain rule에 의해 각 가중치에 대한 그라디언트를 계산하면 얻을 수 있습니다. (그라디언트 = 현재 가중치가 얼마나 잘못되었는지에 대한 벡터) 계산된 가중치를 학습률과 곱해 모든 가중치를 업데이트 합니다. (손 계산) 순전파: 출력 계산과 활성화 함수 대입 반복 후 최종 예측값 도출 sum(입력값 * 웨이트) = 출력값 출력값을 활성화 함수에 넣고 계산 (x에 대입 y 도출) 손실값: 예측값과 실제값을 MSE 공식에 넣고 loss 계산 1/n (sum(손실 - 예측)^2) 역전파: loss의 그라디언트를 러닝 레이트와 곱해 빼서 업데이트 (새 웨이트) = (기존 웨이트) - (그라디언트 loss) * (러닝 레이트) (그라디언트 loss) ∇C = dC/dw (loss의 웨이트 편미분) dC/dw (loss의 웨이트 편미분) = dC/dO * dO/dz * dz/dw (체인 룰) 체인 룰: 두 변수의 미분 관계를 모를 때 각각 아는 미분값으로 연쇄적으로 연결해서 해결 dC/dO (loss의 아웃풋 편미분) * dO/dz (아웃풋의 활성화 함수 z노드 아웃풋 편미분) * dz/dw (z노드 아웃풋의 웨이트 편미분)"
    },
    {
        "질문": "local minima로 인해 딥러닝이 안되는 매커니즘을 설명해주시겠습니까?",
        "답변": "모델이 local minima에 빠지면 더 나은 global minima에 도달하지 못하고 성능 개선이 멈춰버립니다."
    },
    {
        "질문": "saddle point 문제에 대하여 설명해주시겠습니까?",
        "답변": "차원 공간에서 한 방향에서는 최소값을 가지지만 다른 방향에서는 최대값을 가지는 지점을 말합니다. 한 방향에서 미분이 0이 나오고 다른 방향을 줄이려다가 원래 방향의 값이 증가할 수 있는 문제로, 더이상 학습을 진행하지 않을 수 있습니다. 초기 값을 다양하게 설정하거나 모멘텀 기법을 사용하여 해결할 수 있습니다."
    },
    {
        "질문": "찾은 해가 global minima인지 판단하는 방법은 무엇인가요?",
        "답변": "loss function landscape를 시각화하거나 다양한 초기값으로 학습해서 최소값에 변화가 있는지 비교해봅니다."
    },
    {
        "질문": "지도학습과 비지도학습의 objective funtion과 차이를 설명해주시겠습니까?",
        "답변": "지도학습은 실제값과 예측값의 loss를 계산하고 최소화하는 방법을 사용합니다. (ex. MSE, CE) 비지도학습은 데이터의 구조를 파악하고 군집이나 밀도를 목표로 합니다. (ex. 클러스터링, PCA)"
    },
    {
        "질문": "과적합 방지를 위해 사용하는 방법을 모두 설명해주시겠습니까?",
        "답변": "dropout, regularization, batch norm, 데이터 증강 기법, early stopping 등이 있습니다."
    },
    {
        "질문": "dropout의 개념과 사용하는 이유를 설명해주시겠습니까?",
        "답변": "드롭아웃은 학습 시 무작위로 무작위로 뉴런을 비활성화하여 특정 뉴런에 의존하지 않도록 합니다. 과적합을 방지하고 모델의 일반화 성능을 높일 수 있습니다."
    },
    {
        "질문": "정규화(regularization)에 대하여 설명해주시겠습니까?",
        "답변": "과적합 방지를 위한 제약조건으로 L1, L2 등이 있습니다. 이 값을 실제 손실함수에 패널티로 더해주면 모델은 가중치의 크기를 줄이는 방향으로 학습합니다. L1은 lasso로 가중치의 절대값 합을 패널티로 부과합니다. 모델에 중요하지 않은 특성의 가중치를 0으로 만들어 희소성을 유지합니다. L2은 ridge로 가중치의 제곱 합을 패널티로 부과합니다. 전체적인 특성의 가중치를 작은 값으로 만들어 과적합을 방지합니다."
    },
    {
        "질문": "정규화(norm)와 표준화(stand)의 차이점을 설명해주시겠습니까?",
        "답변": "정규화(normalization)는 데이터를 0에서 1 범위로 변환하는 것이고 표준화(standardization)는 평균은 0 분산은 1이 되도록 변환하는 것입니다."
    },
    {
        "질문": "정규화(norm)을 하는 이유를 설명해주시겠습니까?",
        "답변": "학습 중에 특성 간의 크기 차이를 제거하고 특정 뉴런의 의존도가 너무 높지 않도록 하여 학습을 안정화 시킵니다."
    },
    {
        "질문": "batch normalization의 개념과 사용하는 이유를 설명해주시겠습니까?",
        "답변": "배치 노멀라이제이션은 각 미니배치 입력의 평균과 분산을 0과 1로 조절합니다. 따라서 초기값에 의해 특정 미니배치가 과하게 학습되는 과적합 현상을 방지해줍니다."
    },
    {
        "질문": "batch norm과 layer norm의 차이를 설명해주시겠습니까?",
        "답변": "입력 텐서의 (batch, 이미지 토큰 수, dim)이 (64, 196, 768)인 예시로 설명하겠습니다. batch norm은 같은 토큰 같은 dim에서 batch를 기준으로 값을 정규화하는 것입니다. 입력 값의 분포가 학습 중에 변하는 것을 방지합니다. 하지만 배치에 의존적이기 때문에 작은 배치에서는 효과가 불안정할 수 있습니다. layer norm은 같은 토큰 같은 batch에서 dim을 기준으로 값을 정규화하는 것입니다. 같은 샘플 내의 뉴런의 의존도 편향을 방지합니다. 따라서 배치에 독립적이고 작은 배치에서도 안정적으로 동작합니다."
    },
    {
        "질문": "softmax 함수에 대하여 설명해주시겠습니까?",
        "답변": "여러 클래스의 점수를 확률로 변환하는 함수 입니다. 모든 출력값의 합이 1이 되도록 normalization 해줍니다."
    },
    {
        "질문": "softmax 함수의 수식을 설명해주시겠습니까?",
        "답변": "여러 개의 실수값을 입력받아 0에서 1 사이의 확률값으로 변환하는 함수 입니다. 각 입력값에 지수함수를 적용하고 (해당 지수값) / (모든 지수값의 합)으로 나타낼 수 있습니다."
    },
    {
        "질문": "분포가 불균형한 데이터를 분류 할 때 발생하는 문제는 무엇인가요?",
        "답변": "구성 비율이 낮은 클래스가 무시되어 모델이 편향되고 성능이 떨어집니다. 오버샘플링이나 언더샘플링을 사용하면 문제를 해결할 수 있습니다."
    },
    {
        "질문": "cost function과 activation function을 설명해주시겠습니까?",
        "답변": "cost function은 loss function으로 실제값과 예측값의 차이를 계산합니다. (ex. MSE, CE) activation function은 뉴런의 출력을 결정하고 모델에 비선형성을 부여합니다. (ex. relu, softmax)"
    },
    {
        "질문": "파이토치와 텐서플로우의 특징과 차이를 설명해주시겠습니까?",
        "답변": "파이토치는 더 파이써닉한 코드라 가독성이 좋습니다. 또한 실행 중에 텐서를 이용해 동적으로 그래프를 그릴 수 있어 디버깅이 편합니다. 텐서플로우는 배포의 용이성과 텐서보드 시각화에 강점이 있습니다. 또한 미리 그래프를 선언해 정적인 그래프를 그릴 수 있어 속도가 빠릅니다."
    },
    {
        "질문": "하이퍼 파라미터는 무엇인지 설명해주시겠습니까?",
        "답변": "학습 전에 사람이 직접 설정하는 파라미터로 모델의 성능에 큰 영향을 미칩니다. learning rate, batch size, epoch, dim, block 수 등이 있습니다."
    },
    {
        "질문": "weight initialization 개념과 종류를 설명해주시겠습니까?",
        "답변": "가중치의 초기값을 설정하는 방법으로 ±0.1 사이의 균일한 분포 값을 넣는 랜덤, 입출력 뉴런 수를 고려한 xavier 방법 등이 있습니다."
    },
    {
        "질문": "training set과 test set을 분리하는 이유를 설명해주시겠습니까?",
        "답변": "모델의 일반화 성능을 객관적으로 평가하기 위해서 입니다. 과적합된 경우 학습에 사용한 데이터는 모델이 이미 외우고 있을 수 있습니다."
    },
    {
        "질문": "validation set이 필요한 이유를 설명해주시겠습니까?",
        "답변": "하이퍼 파라미터 튜닝이나 학습 중간에 경과를 평가하기 위해서 사용합니다."
    },
    {
        "질문": "GPU를 사용하는 이유를 설명해주시겠습니까?",
        "답변": "병렬 연산이 가능해서 CPU보다 더 빠른 속도로 학습할 수 있습니다. 딥러닝은 행렬 연산을 많이 사용하기 때문에 GPU를 사용합니다."
    },
    {
        "질문": "GPU를 두개 사용하는 방법을 설명해주시겠습니까?",
        "답변": "배치를 나눠서 각 GPU에서 병렬로 데이터를 처리할 수 있습니다. 파이토치에서 분산학습 메서드인 DistributedDataParallel를 사용하면 됩니다."
    },
    {
        "질문": "학습에 필요한 GPU 메모리를 계산하는 방법을 설명해주시겠습니까?",
        "답변": "배치크기 * 파라미터수 * 4(float32)로 계산할 수 있고 모델 (인스턴스, 그라디언트, 옵티마이저)를 고려해 4배 정도 됩니다."
    },
    {
        "질문": "트랜스포머의 전체적인 구조를 설명해주시겠습니까?",
        "답변": "인코더-디코더 구조로 되어 있고 어텐션 레이어를 사용합니다. 인코더에는 셀프어텐션, 디코더에는 masked 셀프어텐션, 인코더-디코더 어텐션 구조로 되어 있습니다. 인코더와 디코더의 마지막에는 Feed Forwad Network가 있고 어텐션 레이어와 FFN 뒤에는 residual connection과 norm을 진행합니다. 입력이 들어오면 이를 임베딩으로 만들고 포지션 임베딩을 더해줍니다. 그리고 인코더-디코더 구조를 거친 뒤 최종 임베딩을 linear layer와 softmax를 거쳐 최종 결과를 냅니다."
    },
    {
        "질문": "트랜스포머가 위치정보를 전달하는 방법을 설명해주시겠습니까?",
        "답변": "포지션 임베딩을 사용하여 위치 정보를 전달합니다. sin, cos 함수를 기반으로 인코딩하며 순차성은 있지만 의미 정보가 변질되지 않도록 ±1사이의 값입니다. 주기성을 이용하여 각 위치마다 고유한 패턴을 만들어냅니다."
    },
    {
        "질문": "어텐션 매커니즘의 과정을 수식으로 설명해주시겠습니까?",
        "답변": "입력 임베딩에 Q, K, V 매트릭스를 내적해 Q, K, V 벡터를 먼저 얻을 수 있습니다. 현재 단어의 Q와 모든 단어의 K의 전치행렬을 각각 내적하여 각각의 어텐션 스코어를 구하고 이를 softmax 함수에 넣어 각각의 어텐션 웨이트를 구합니다. 각각의 어텐션 웨이트를 각각의 V와 곱한뒤 모두 더해 컨텍스트 벡터를 구할 수 있습니다. 이 컨텍스트 벡터는 QKV 벡터와 같은 사이즈의 행렬이며 다음 시점의 모델에 입력입니다."
    },
    {
        "질문": "어텐션 매커니즘의 Q, K, V 벡터의 정성적인 의미를 설명하라.",
        "답변": "Q는 현재 단어가 필요로 하는 정보에 대한 representation 입니다. 그리고 K와 V는 입력 시퀀스의 각 단어에 대한 특징으로 보통 같은 값을 사용하지만 용도가 다릅니다. K는 어텐션 스코어 계산에 사용되며 V는 컨텍스트 벡터 계산에 사용됩니다. 어텐션 스코어는 현재 단어의 Q와 각 단어 K의 유사도를 의미하며 어텐션 웨이트는 현재 단어에 대한 각 단어의 중요도를 의미합니다. 컨텍스트 벡터는 현재 시점에서 각 단어 간의 중요도에 대한 요약을 의미합니다."
    },
    {
        "질문": "인코더 셀프 어텐션과 디코더 셀프 어텐션의 차이를 설명해주시겠습니까?",
        "답변": "인코더 셀프 어텐션은 모든 단어를 사용할 수 있지만 디코더 셀프 어텐션은 마스킹 때문에 현재 위치 까지의 단어만 사용할 수 있습니다. 또한 인코더-디코더 어텐션의 경우 인코더 셀프 어텐션의 결과를 K, V로 디코더 셀프 어텐션의 결과를 Q로 사용합니다."
    },
    {
        "질문": "BERT와 GPT의 차이점을 설명해주시겠습니까?",
        "답변": "BERT는 양방향 인코더 기반으로 입력 시퀀스의 모든 토큰을 사용할 수 있고 Masked Language Model 과 Next Sentence Prediction으로 학습합니다. 반면에 GPT는 단방향 디코더 기반으로 현재 위치 까지의 단어만 사용할 수 있고 다음 단어를 예측하는 task로 학습합니다. BERT는 문장을 이해하거나 분류하는데 강점을 보이고 GPT는 텍스트 생성에 강점을 보입니다."
    },
    {
        "질문": "랭체인에 대하여 설명해주시겠습니까?",
        "답변": "랭체인은 LLM을 쉽고 효율적으로 사용할 수 있게 도와주는 프레임워크 입니다. GPT, 클로드 처럼 회사가 다른 여러 AI 모델을 API를 사용해 같이 사용할 수도 있고, 외부 데이터를 LLM에 쉽게 연결할 수도 있습니다."
    },
    {
        "질문": "RAG에 대하여 설명해주시겠습니까?",
        "답변": "RAG는 Retrieval Augmented Generation으로 LLM이 답변할 때 외부 데이터베이스에서 관련 정보를 찾아와서 참고하면서 대답하는 방식입니다. 예를 들어, 회사 내부 문서를 참고해서 답변하는 것입니다. 최신 정보를 사용할 수 있는 장점과 출처가 있기 때문에 할루시네이션이 적은 장점이 있습니다. 문제점은 우리가 사용하는 PDF, 워드, 엑셀 같은 문서들이 출판용 구조이거나 테이블로 되어 있어 파싱 문제로 잘 작동하지 않습니다. 해결하기 위해 전처리와 텍스트 추출을 하는 것이 필요합니다."
    },
    {
        "질문": "ToD에 대하여 설명해주시겠습니까?",
        "답변": "ToD는 Task-oriented Dialogue로 특정 목적을 달성하기 위한 대화 시스템입니다. 예를 들어, 식당 예약 같은 구체적인 작업을 완료하기 위한 대화 태스크 입니다. NLU, DST, DP, NLG 4가지 모듈로 구성되어 있습니다."
    },
    {
        "질문": "LoRA에 대하여 설명해주시겠습니까?",
        "답변": "LoRA(Low-Rank Adaptation)는 대형 언어모델을 효율적으로 파인튜닝하는 기법입니다. 기존 가중치 행렬을 고정하고, 두 개의 작은 행렬 A와 B의 곱(A×B)을 더해서 모델을 적응시킵니다. 핵심 아이디어는 파인튜닝 시 필요한 가중치 변화량이 저순위 행렬로 표현될 수 있다는 가정입니다. 예를 들어 4096×4096 행렬을 rank 16으로 분해하면, 1600만 개 파라미터를 13만 개로 줄일 수 있습니다. 주로 Transformer의 어텐션 레이어(Q, K, V, O 투영 행렬)에 적용되며, 메모리 사용량과 훈련 시간을 대폭 줄이면서도 전체 파인튜닝과 비슷한 성능을 달성할 수 있습니다."
    },
    {
        "질문": "PEFT에 대하여 설명해주시겠습니까?",
        "답변": "PEFT(Parameter-Efficient Fine-Tuning)는 대형 언어모델을 효율적으로 파인튜닝하기 위한 기법들의 총칭입니다. 전체 모델 파라미터를 업데이트하는 대신, 소수의 파라미터만 조정하여 특정 작업에 적응시키는 방법론입니다. 주요 기법으로는 LoRA(저순위 행렬 분해) 등이 있습니다. 허깅페이스에 라이브러리로 구현되어 있습니다."
    },
    {
        "질문": "CNN의 연산과정을 설명해주시겠습니까?",
        "답변": "입력 이미지에 필터를 슬라이딩하며 컨볼루션 연산을 수행합니다. 이때 필터와 이미지의 각 부분을 곱하고 더하면서 특징을 추출합니다. 또한 활성화함수로 비선형성을 추가하고 풀링 레이어로 피쳐맵의 크기를 줄입니다."
    },
    {
        "질문": "ResNet의 핵심 개념을 설명해주시겠습니까?",
        "답변": "residual connection을 통해 더 깊은 층으로 구성된 모델도 학습이 가능합니다. 이전 블럭의 결과를 이번 블럭의 결과에 더해주는 구조로 gradiant vanishing 문제를 해결하고 깊은 층의 레이어도 학습할 수 있습니다."
    },
    {
        "질문": "MobileNet의 핵심 개념을 설명해주시겠습니까?",
        "답변": "기존 컨볼루션을 depth-wise, point-wise conv로 대체했습니다. 연산을 두단계로 나눠서 하면 연산량이 크게 줄어드는데 이 트릭을 사용한 것입니다. depth-wise conv는 채널 간의 정보는 혼합되지 않고 공간적 특징만 추출하며 3x3 커널을 사용합니다. point-wise conv는 공간적 정보는 건드리지 않고 채널의 정보만 혼합해 특징을 추출하며 1x1 커널을 사용합니다."
    },
    {
        "질문": "EfficientNet의 핵심 개념을 설명해주시겠습니까?",
        "답변": "네트워크의 depth, width, resolution을 균형있게 키우는 것입니다. compound scaling이라고 해서 작은 베이스 모델을 만들고 세가지 요소를 동시에 키워나갑니다."
    },
    {
        "질문": "CNN과 ViT의 차이를 설명해주시겠습니까?",
        "답변": "두 모델 모두 특징 추출을 하는 모델이지만 추출 매커니즘에 차이가 있습니다. CNN은 로컬 픽셀들 간의 관계에서 패턴을 찾고 ViT는 이미지 패치들 간의 관계에서 패턴을 찾습니다. CNN은 부분적 특징을 추출하는데 강점을 보이고 ViT는 전역적 관계를 추출하는데 강점을 보입니다."
    },
    {
        "질문": "CNN과 ViT에서 XAI 방법론을 설명해주시겠습니까?",
        "답변": "CNN은 주로 Grad-CAM, Class Activation Map을 사용해 이미지의 어디 부분을 보고 판단했는지 시각화 합니다. ViT는 어텐션 맵을 통해 각 패치가 다른 패치와 얼마나 상호작용을 하는지 봅니다."
    },
    {
        "질문": "CNN에 비해 ViT의 학습 속도가 느린 이유를 설명해주시겠습니까?",
        "답변": "CNN은 커널을 사용하고 픽셀 사이에 관계가 있다는 가정을 아키텍처에 내포하여 학습합니다. 반면 ViT는 이런 가정이 없고 패치 사이의 관계에서 특징을 추출합니다. 따라서 가정 없이 학습하는 ViT는 모든 관계를 새로 학습해야하기 때문에 학습 속도가 느립니다. 계산 복잡도 측면에서도 셀프 어텐션 연산은 시퀀스 길이의 제곱에 비례하고 컨볼루션 연산은 커널 크기와 이미지 크기에 비례합니다."
    },
    {
        "질문": "ViT가 프리트레이닝이 필요한 이유를 트랜스포머와 연결하여 설명해주시겠습니까?",
        "답변": "CNN는 주변 픽셀과 관계가 있다는 가정이 있지만 ViT는 이런 가정이 없기 때문입니다. 트랜스포머 구조는 원래 NLP 태스크를 위해 만들어졌습니다. 텍스트는 단어 단위로 나뉘어지는데 이미지에서도 인위적으로 패치 단위로 나누게 됩니다. 이 과정에서 CNN과 같은 가정이 사라지고 모든 관계를 새로 학습하기 때문에 프리트레이닝이 필요합니다. 대규모 데이터셋으로 프리트레이닝을 하면 이미지의 일반적인 특성을 학습할 수 있습니다. 이 일반적인 특징이 세부 태스크나 작은 데이터셋에서 좋은 성능을 낼 수 있게 합니다."
    },
    {
        "질문": "inductive bias에 대하여 설명해주시겠습니까?",
        "답변": "학습하는 과정에서 생긴 사전 가정으로 인간의 선입견과 유사합니다. 학습 데이터나 아키텍처에 의해 발생합니다. CNN의 경우에는 근처 픽셀 간에 관계에 대한 인덕티브 바이어스가 생기고, ViT의 경우 상대적으로 인덕티브 바이어스가 없지만 패치 단위로 이미지를 나누는 것에 대한 인덕티브 바이어스가 있습니다."
    },
    {
        "질문": "딥러닝 이전에 detection에 사용했던 방법을 설명해주시겠습니까?",
        "답변": "이미지의 경계와 방향을 분석하는 HOG와 이미지의 밝기 차이를 특정하여 눈코입의 패턴을 감지하는 Haar와 같은 방법이 있습니다."
    },
    {
        "질문": "Faster R-CNN의 모델에 대하여 설명해주시겠습니까?",
        "답변": "Faster R-CNN은 2 stage 디텍션 모델입니다. Fast R-CNN에 select search 대신 RPN을 사용해 속도를 개선한 모델입니다. RPN이 객체가 있을 만한 영역을 먼저 찾은 후 Fast R-CNN이 객체를 분류하고 박스를 정교하게 조정합니다. RPN: Region Proposal Network, ROI (Region of Interest)를 자동 생성 장점으로 ROI 풀링과 ResNet 백본의 영향으로 정확도가 높습니다. 단점으로 네트워크가 2단계로 진행되어 실시간 처리가 어렵고 모듈수가 많아 구조가 복잡합니다."
    },
    {
        "질문": "YOLO의 모델에 대하여 설명해주시겠습니까?",
        "답변": "YOLO는 1 stage 디텍션 모델입니다. 이미지를 그리드로 나누고 한번에 객체 검출을 수행하는 방식을 사용합니다. 각 그리드 셀이 객체의 클래스와 바운딩 박스를 한번에 예측하고 NMS로 중복된 박스를 소거합니다. NMS: Non-Maximum Suppression, 중복 검출 결과를 제거하는 후처리 기법입니다. 하나의 객체에 대하여 여러개의 바운딩 박스가 예측되면, 박스 중에 컨피던스 스코어가 가장 높은 박스만 선택합니다. 이 박스와 많이 겹치는 (IoU가 높은) 박스는 제거합니다. 장점으로 실시간 처리가 가능할 정도로 빠르고 end-to-end CNN 형태로 구조가 간단합니다. 단점으로 격자 기반 예측 방식으로 인해 작은 크기의 객체 인식 성능이 낮고 속도에 중점을 뒀기 때문에 상대적으로 정확도가 낮습니다."
    },
    {
        "질문": "가장 선호하는 객체인식 알고리즘을 설명하고 장단점을 설명해주시겠습니까?",
        "답변": "YOLO 입니다. 실시간 처리가 가능하며 end-to-end 모델이라는 점이 제가 추구하는 방향이랑 동일하기 때문입니다."
    },
    {
        "질문": "DETR 모델에 대하여 설명해주시겠습니까?",
        "답변": "DEtection TRansformer는 메타 연구진이 발표한 객체 인식 모델입니다. 기존 모델의 복잡한 후처리 과정인 RPN과 NMS를 없애고 트랜스포머를 사용해 end-to-end로 학습이 가능합니다. 그리고 고정된 숫자의 object query를 사용해서 이미지 내 객체를 직접 예측하고, object query에서 FFN을 통해 객체의 클래스와 위치를 예측합니다."
    },
    {
        "질문": "CLIP 모델에 대하여 설명해주시겠습니까?",
        "답변": "Contrastive Language-Image Pre-training은 오픈AI가 발표한 멀티모달 모델입니다. 이미지와 텍스트를 같은 스페이스에 매핑해서 둘 사이의 관계를 학습하는 모델로 contrastive learning을 사용합니다. contrastive learning: 같은 이미지-텍스트 쌍은 가깝게, 관계없는 이미지-텍스트 쌍은 멀게 학습히는 방법입니다. cosine similarity로 유사도를 계산하는 InfoNCE Loss를 사용합니다."
    },
    {
        "질문": "LLaVA 모델에 대하여 설명해주시겠습니까?",
        "답변": "LLM 모델인 LLaMA에 CLIP의 비전 인코더를 연결한 멀티모달 모델입니다. instruction tuning으로 시각-언어 데이터의 기본 능력을 학습하고 GPT-4의 데이터로 미세조정을 했습니다. instruction tuning: CLIP의 이미지 임베딩을 LLM의 토큰 임베딩과 정렬하는 것을 목적으로 하며, CLIP의 이미지 임베딩을 LLM의 토큰 임베딩으로 변환하는 프로젝션 레이어를 학습합니다."
    },
    {
        "질문": "최신 VLM 모델에 대하여 설명하라 (2025.02)",
        "답변": "DALL-E-3, GPT-4V, Claude 3, MoE-LLaVA, LLaVA-CoT 등이 있습니다. 이미지 인코더와 기존 LLM을 합치는 방향으로 연구가 진행되고 있고 MoE 나 CoT 같은 메서드가 활용되고 있습니다. MoE: Mixture of Experts, 여러 전문가 네트워크를 조합해 효율적인 추론을 하는 방식입니다. CoT: Chain of Thought, 복잡한 추론을 단계적으로 수행하는 방식입니다."
    },
    {
        "질문": "avg pooling과 max pooling의 차이를 설명해주시겠습니까?",
        "답변": "풀링 레이어는 입력 데이터의 크기를 줄이면서 중요한 특징을 추출합니다. avg pooling은 영역 내 모든 값의 평균을 취해 전반적인 특징을 보존하고 max pooling은 영역 내 최댓값만 선택해 가장 두드러진 특징만 유지합니다. 일반적으로 max pooling을 더 많이 사용합니다."
    },
    {
        "질문": "semantic segmentation을 설명해주시겠습니까?",
        "답변": "이미지의 각 픽셀을 특정 클래스로 분류하는 작업 입니다. 대표적인 모델으로 FCN, U-Net이 있습니다."
    },
    {
        "질문": "CNN이 MLP보다 좋은 이유는 무엇인가요?",
        "답변": "CNN은 필터를 사용하는데 이는 곧 파라미터를 공유하는 것으로 메모리를 효율적으로 사용할 수 있고 주변 픽셀과의 관계를 학습할 수 있습니다."
    },
    {
        "질문": "CNN의 파라미터 수를 계산하는 방법을 설명해주시겠습니까?",
        "답변": "(커널 크기 * 커널 크기 * 입력 채널 * 출력 채널) + 출력 채널 입니다."
    },
    {
        "질문": "볼츠만 머신을 설명해주시겠습니까?",
        "답변": "현재 딥러닝 네트워크의 전신인 restricted 볼츠만 머신은 가시층과 은닉층으로 구성되어 있습니다. 각 층의 노드들은 확률적 상태를 가지며 실제값과 재구성값의 차이를 가중치 업데이트에 활용합니다. 역전파 알고리즘 없이 학습하는 초기의 딥러닝 알고리즘 입니다. 이 RBM이 곧 FC layer와 동일한 구조를 가집니다."
    },
    {
        "질문": "오토인코더를 설명해주시겠습니까?",
        "답변": "입력을 압축했다가 복원하는 비지도학습 모델입니다. 인코더는 입력을 저차원으로 점차 압축하고 디코더는 압축된 정보를 원본 차원으로 점차 복원합니다."
    },
    {
        "질문": "머신러닝이란 무엇인가요?",
        "답변": "데이터에서 패턴을 학습하여 새로운 데이터에 대한 예측을 하는 알고리즘을 말합니다."
    },
    {
        "질문": "머신러닝의 학습법 종류를 설명해주시겠습니까?",
        "답변": "지도학습, 비지도학습 등이 있습니다. 지도학습은 정답이 있는 데이터로 학습하는 것으로 종류는 분류와 회귀가 있습니다. 비지도학습은 정답 없이 데이터의 패턴을 발견하는 것으로 종류는 군집화와 차원축소가 있습니다. 이외에도 강화학습, 자기지도학습 등이 있습니다."
    },
    {
        "질문": "precision, recall 공식과 개념을 설명해주시겠습니까?",
        "답변": "프리시전은 양성으로 예측한 것 중에 실제 양성인 비율으로 TP/(TP+FP) 입니다. 리콜은 실제 양성 중에 양성이라 예측한 비율으로 TP/(TP+FN) 입니다."
    },
    {
        "질문": "precision, recall의 중요성과 trade-off의 본질은 무엇인가요?",
        "답변": "정성적인 의미로 프리시전은 불량이 아닌 것도 얼마나 과하게 검출을 했는가를 평가하는 것이고, 리콜은 불량인 것들 중에서 몇개를 놓쳤는가를 평가하는 것입니다. 모델을 어떤 각도로 평가하는지에 따라 중요성이 달라지며 동일한 성능이라고할 때 하나를 높이면 하나는 내려갈 수 밖에 없습니다. 예를들어 모델의 성능은 같은데 불량을 놓치지 않고 싶다면 과하게 검사할 수 밖에 없는 것입니다."
    },
    {
        "질문": "F1 공식과 의미를 설명해주시겠습니까?",
        "답변": "2*(프리시전*리콜)/(프리시전+리콜)으로 두 값의 조화평균 입니다. 두 지표가 균형있게 좋은지 평가하는 지표 입니다."
    },
    {
        "질문": "매크로 F1 스코어와 마이크로 F1 스코어 차이를 설명해주시겠습니까?",
        "답변": "매크로 F1 스코어는 각 클래스별 F1 스코어의 평균을 구해 모든 클래스를 동등하게 비교합니다. 반면 마이크로 F1 스코어는 전체 데이터에서 프리시전과 리콜을 먼저 계산하고 F1을 구해 데이터가 더 많은 클래스에 많은 가중치를 줍니다. 소수의 클래스도 중요하면 매크로 F1 스코어를, 다수 클래스가 중요하면 마이크로 F1 스코어를 사용하면 됩니다."
    },
    {
        "질문": "선형 회귀의 기본 가정은 무엇인가요?",
        "답변": "선형 회귀는 선형성, 독립성, 등분산성, 정규성을 가정합니다. 선형성(독립 변수와 종속 변수의 선형관계), 독립성(오차들이 서로 독립), 등분산성(오차의 분산이 일정), 정규성(오차가 정규분포를 따름) (y = w1x1 + w0 + ε에서 ε가 오차. 얼마나 설명하지 못했는지를 나타냄.)"
    },
    {
        "질문": "KNN과 K-means에 대하여 설명해주시겠습니까?",
        "답변": "KNN은 해당 데이터의 K개 이웃의 다수결에 의해 분류하는 지도학습이고, K-means는 랜덤으로 클러스터 중심을 정하고 클러스터에 속한 샘플의 평균값으로 중심을 변경하며 최적의 군집을 찾는 비지도학습 입니다."
    },
    {
        "질문": "DBSCAN과 GMM에 대하여 설명해주시겠습니까?",
        "답변": "DBSCAN은 특정 반경 내에 있는 점들의 갯수가 일정 수 이상이면 하나의 군집으로 만들며, GMM은 여러 개의 가우시안 분포를 섞어서 데이터를 모델링 합니다. 각 모델의 하이퍼파라미터는 DBSCAN은 반경인 입실론과 최소 수인 min 이고, GMM은 군집 수 입니다. 각 모델의 특징은 DBSCAN은 군집 수를 정하지 않아도 되지만 밀도가 다양하면 작동하지 않는 것이고, GMM은 데이터가 겹쳐도 잘 작동하지만 군집 수를 정해야하는 단점이 있습니다."
    },
    {
        "질문": "데이터 샘플링을 설명해주시겠습니까?",
        "답변": "데이터의 일부를 추출하여 분석이나 학습에 사용하는 것 입니다. 무작위로 선택하는 random 샘플링, 종속변수의 클래스 비율을 유지하는 stratify 샘플링, 복원추출 방식을 사용하는 부트스트랩 샘플링 등이 있습니다."
    },
    {
        "질문": "부트스트랩 샘플링에 대하여 설명해주시겠습니까?",
        "답변": "데이터를 샘플링하고 다시 되돌려 놓는 복원추출 방식으로 여러 개의 데이터셋을 생성하는 방법입니다. 제한된 샘플 데이터로부터 더 큰 통계적 추론을 만들어낼 수 있습니다."
    },
    {
        "질문": "앙상블 학습에 대하여 설명해주시겠습니까?",
        "답변": "보팅, 배깅, 스태킹, 부스팅 등이 있습니다. 보팅 (서로 다른 모델의 투표 결과로 예측), 배깅 (하나의 모델을 부트스트랩 샘플링한 데이터에 대하여 학습하고 결과를 집계), 스태킹 (서로 다른 모델을 부트스트랩 샘플링한 데이터에 대하여 학습하고 결과를 집계), 부스팅 (여러개의 클래시파이어가 가중치를 전달하며 순차적으로 학습)."
    },
    {
        "질문": "PCA가 무엇이고 언제 사용하는가",
        "답변": "차원축소 기법 중에 하나로 데이터를 압축할 때 사용합니다. 분산을 최대한 보존하면서(데이터의 특징을 잘 설명하면서) 직교하는 새로운 축을 찾아 투영하는 방식으로 차원을 축소하는 기법입니다."
    },
    {
        "질문": "RMSE, MSE, MAE의 수식과 차이점을 설명해주시겠습니까?",
        "답변": "MSE는 오차의 제곱의 평균이고 RMSE는 MSE의 제곱근 입니다. MAE는 오차의 절대값의 평균입니다. 제곱이나 평균은 부호를 제거하기 위해서 사용하고 루트는 제곱이 실제값과 크기가 달라지기 때문에 사용합니다."
    },
    {
        "질문": "CE에 대하여 설명해주시겠습니까?",
        "답변": "(원핫 인코딩된 실제값) * 로그 (예측 확률)을 모두 더한 값으로 예측 확률 분포와 실제 정답 분포 간의 차이를 계산합니다."
    },
    {
        "질문": "Markov Chain을 설명해주시겠습니까?",
        "답변": "현재 상태가 직전 상태에만 의존하는 확률 과정입니다. 다음 상태는 오직 현재 상태에만 영향을 받으며, 과거 상태들은 고려하지 않습니다. 날씨 예측이나 주가 예측 등에 활용됩니다."
    },
    {
        "질문": "SVM에 대하여 설명해주시겠습니까?",
        "답변": "두 클래스 간의 경계를 찾는 알고리즘으로 마진을 최대화하는 초평면을 찾는 것을 objective로 하는 알고리즘 입니다."
    },
    {
        "질문": "SVM은 왜 반대로 차원을 확장시키는 방법을 사용하는지 설명해주시겠습니까?",
        "답변": "저차원에서 선형 분리가 불가능한 데이터를 고차원으로 매핑하면 선형 분리가 가능한데 이를 커널 트릭이라고 합니다. 이렇게 프로젝션과 연산으로 두단계로 한다면 계산량이 늘어나지만 내적을 활용하면 한번에 효율적으로 계산할 수 있습니다."
    },
    {
        "질문": "회귀와 분류에 알맞은 matric을 선택하고 설명해주시겠습니까?",
        "답변": "회귀는 큰 오차가 있을 경우 MSE가 적절하고 이상치가 있을 경우 MAE가 적절합니다. 분류는 accuracy가 보편적으로 좋지만 데이터 불균형이 있을 경우 F1이 적절합니다."
    },
    {
        "질문": "인공신경망이 가지는 문제점을 설명해주시겠습니까?",
        "답변": "학습 데이터의 양이 많아야하고 학습에 많은 양의 컴퓨팅 리소스를 필요로 합니다. 또한 블랙박스로 모델 해석이 어렵습니다."
    },
    {
        "질문": "ROC 커브에 대하여 설명해주시겠습니까?",
        "답변": "이진 분류기의 성능을 시각화하는 그래프입니다. x축은 FP rate, y축은 TP rate를 나타냅니다. 곡선 아래 면적이 클수록 좋은 성능을 의미합니다."
    },
    {
        "질문": "서버가 100개 있을 때 인공신경망보다 랜덤포레스트를 선택해야 하는가",
        "답변": "랜덤포레스트가 더 적합합니다. 각 트리를 독립적으로 학습할 수 있어 병렬 처리가 자연스럽고, 서버 간 통신 부하가 적습니다. 반면 신경망은 파라미터 동기화가 필요해 분산 학습 시 통신 부하가 크고, 학습 안정성도 떨어질 수 있습니다."
    },
    {
        "질문": "cross validation에 대하여 설명해주시겠습니까?",
        "답변": "전체 데이터를 k개의 폴드로 나누어 k-1개로 학습하고 1개로 검증하는 과정을 k번 반복하는 방법입니다. 과적합을 방지하고 모델의 일반화 성능을 평가하는데 유용합니다."
    },
    {
        "질문": "gradient boosting에 대하여 설명해주시겠습니까?",
        "답변": "여러개의 디시전 트리를 순차적으로 학습하는 앙상블 기법입니다. 각 단계에서 이전 모델이 만든 오차를 줄이기 위해 그라디언트를 계산하고 이를 보정하는 방식으로 새 모델을 추가합니다."
    },
    {
        "질문": "XGBoost에 대하여 설명해주시겠습니까?",
        "답변": "그라디언트 부스팅의 계산 효율성과 과적합 방지를 개선한 모델입니다. 병렬 처리와 분산 학습이 가능하고 정규화 기법을 포함하고 있습니다."
    },
    {
        "질문": "LightGBM에 대하여 설명해주시겠습니까?",
        "답변": "그라디언트 부스팅의 속도와 메모리 사용량을 개선한 모델입니다. leaf-wise 방식으로 트리를 생성해 더 깊은 노드까지 효율적으로 학습하고 카테고리컬 데이터를 인코딩 없이 직접 사용할 수 있습니다."
    },
    {
        "질문": "좋은 모델이란 무엇인가요?",
        "답변": "좋은 모델은 과적합 되지 않고 잘 일반화되며 설명이 가능하고 안정적으로 잘 작동하는 모델입니다. 단순히 학습 데이터에서만 성능이 좋은 것이 아니라 실제 문제 해결에 도움이 되어야 합니다."
    },
    {
        "질문": "하이퍼 파라미터 최적화 방법을 설명해주시겠습니까?",
        "답변": "모든 조합을 시도하는 그리드 서치, 레인지 안의 무작위 값을 선택하는 랜덤 서치, 이전 시도 결과를 바탕으로 최적 값을 예측하며 탐색하는 베이지안 옵티마이저 등이 있습니다."
    },
    {
        "질문": "feature selection의 목적과 방법을 설명해주시겠습니까?",
        "답변": "과적합을 방지하고 계산 비용을 줄이기 위함입니다. filter 방법으로 상관계수가 높으면 소거할 수 있고, wrapper 방법으로 성능을 보고 선택할 수 있고, embedded 방법으로 학습 과정에서 소거하여 선택할 수 있습니다."
    },
    {
        "질문": "데이터 불균형이 무엇이고 해결하는 방법을 설명해주시겠습니까?",
        "답변": "특정 클래스의 데이터가 다른 클래스에 비해 매우 적은 상황으로 오버피팅이나 언더피팅을 유발합니다. 오버샘플링, 언더샘플링, 클래스 가중치 설정 등을 통해서 해결할 수 있습니다."
    },
    {
        "질문": "다중공산성을 설명하고 문제가되는 이유는 무엇인지 설명해주시겠습니까?",
        "답변": "feature들 간에 강한 상관관계가 있는 현상입니다. feature를 많이 사용하더라도 대부분 같은 의미를 설명하기 때문에 소용이 없게 됩니다. 따라서 성능이 낮게 나올 가능성이 큽니다."
    },
    {
        "질문": "차원의 저주에 대하여 설명해주시겠습니까?",
        "답변": "고차원의 데이터에서 차원이 증가할수록 학습에 필요한 데이터의 양이 기하급수적으로 증가하는 현상입니다. 거리 기반 알고리즘의 성능이 저하되고 데이터 밀도가 희박해져 과적합될 가능성이 큽니다. 따라서 차원축소가 필요합니다."
    },
    {
        "질문": "feature importance와 shapley vlaue의 주된 차이는 무엇이고 어떤 분석을 선호하는지 설명해주시겠습니까?",
        "답변": "feature importance는 컬럼이 데이터셋 전체적으로 얼마나 영향력이 있는지 측정하는 것이고 shapley value는 컬럼이 각 예측 하나하나에 대한 개별 기여도와 방향성을 계산합니다. 따라서 로컬과 글로벌 해석이 모두 가능한 shapley value를 더 선호합니다."
    },
    {
        "질문": "편향과 분산에 대하여 각각 설명해주시겠습니까?",
        "답변": "bias는 예측값이 실제값과 얼마나 다른지를 나타냅니다. variance는 데이터의 변화에 따라 모델의 예측이 얼마나 달라지는지를 나타냅니다. 예를들어 bias가 높고 variance가 낮은 모델은 탄착군은 형성되지만 중심을 못맞추는 사수라고 볼 수 있고 variance가 높고 bias가 낮은 모델은 중심 근처를 맞추지만 넓게 퍼진 형태로 쏘는 사수라고 볼 수 있습니다."
    },
    {
        "질문": "p-value를 모르는 사람에게 설명해주시겠습니까?",
        "답변": "가정한 결과가 우연히 나올 확률 입니다. 예를 들어 p-value가 0.05라면 이런 결과가 우연히 나올 확률이 5%밖에 안 된다는 의미로, 결과가 통계적으로 의미있다고 볼 수 있습니다."
    },
    {
        "질문": "R^2의 의미는 무엇인가요?",
        "답변": "모델이 데이터의 변동을 얼마나 잘 설명하는지를 나타내는 지표입니다. 0~1 사이의 값을 가지며, 일반적으로 0.64가 넘으면 모델의 설명력이 좋다고 판단합니다. 결정계수는 상관계수의 제곱값으로 계산할 수 있습니다."
    },
    {
        "질문": "시그마는 무엇이고 1~3 시그마 값은 몇인가요?",
        "답변": "시그마는 표준편차를 의미합니다. 정규분포를 가정하면 중심으로부터 ±1시그마 = 68%, ±2시그마 = 95%, ±3시그마 = 99.7% 입니다. (2시그마랑 p-value 0.05랑 비슷한 수준)"
    },
    {
        "질문": "평균과 중앙값의 차이와 사용 예시를 설명해주시겠습니까?",
        "답변": "모든 값의 합을 개수로 나눈 값으로 이상치에 민감합니다. 반면에 중앙값은 데이터를 정렬했을 때 가운데 있는 값으로 이상치의 영향이 적습니다."
    },
    {
        "질문": "중심극한정리를 설명해주시겠습니까?",
        "답변": "표본의 크기가 충분히 크면, 표본평균의 분포는 정규분포에 가까워진다는 이론입니다. 이는 모집단의 분포와 관계없이 성립합니다."
    },
    {
        "질문": "엔트로피와 information gain을 설명해주시겠습니까?",
        "답변": "엔트로피는 데이터의 불확실성을 측정하는 지표이고 information gain은 특정 특성으로 분할했을 때 줄어드는 엔트로피의 양입니다. 디시전 트리에서 사용합니다."
    },
    {
        "질문": "probability와 likelyhood의 차이를 설명해주시겠습니까?",
        "답변": "probability는 주어진 모수에서 특정 데이터가 관찰될 확률이고 likelyhood는 관찰된 데이터가 주어졌을 때 특정 모수가 맞을 가능성입니다. probability는 공정하다는 것을 가정하고 미래의 결과를 예측하는 것이고 likelyhood는 이미 결과를 관찰한 뒤 동전이 공정할 가능성을 평가합니다."
    },
    {
        "질문": "베이지안과 프리퀀티스트의 차이를 설명하고 본인의 의견을 설명해주시겠습니까?",
        "답변": "베이지안은 확률을 확률변수로 해석하고 사전 확률을 설정한 뒤 새로운 데이터로 확률을 업데이트합니다. 반면, 프리퀀티스트는 확률을 장기적인 빈도로 해석하고 확률를 고정된 값으로 봅니다. 베이지안의 입장에서 확률은 불확실성이 있고 계속 변하는 것이고 프리퀀티스트의 입장에서 확률은 이미 많은 데이터에 의해 결정된 것 입니다. 저는 프리퀀티스트 입니다. 통계적 검정인 p-value 0.05, 상관계수 0.8 등을 활용하는 편이고 데이터는 객관적이고 진실을 반영하며 데이터에 의한 의사결정을 추구하기 때문입니다."
    },
    {
        "질문": "missing value가 있을 경우 채워넣을 것인가요?",
        "답변": "데이터가 랜덤하게 없을 경우 평균값이나 중앙값으로 대체할 것이고 특정한 패턴이 발견될 경우 그 자체로 의미있는 정보일 가능성이 있으므로 별도로 처리할 것입니다."
    },
    {
        "질문": "아웃라이어를 판단하는 기준은 무엇인가요?",
        "답변": "통계적으로 Q1 - 1.5xIQR 과 Q3 + 1.5xIQR을 넘어간 값 입니다. (z-score 3시그마 추가 질문 시 대답)"
    },
    {
        "질문": "아이겐벡터와 아이겐벨류가 무엇이고 왜 중요한가",
        "답변": "아이겐벡터는 선형변환 후에도 방향이 유지되는 벡터이고 아이겐벨류는 해당 벡터의 스케일 변화량 입니다. 차원축소 알고리즘에서 활용할 수 있고 복잡한 선형 변환을 간소화시켜주기 때문에 중요합니다."
    },
    {
        "질문": "상관관계와 인과관계의 차이점을 설명해주시겠습니까?",
        "답변": "상관관계는 두 변수 간의 통계적 연관성이 있다는 것으로 선형이나 비선형관계가 있다는 것 입니다. 인과관계는 긴밀한 원인 결과 관계가 있다는 것으로 한 변수가 다른 변수에 직접적인 영향을 준다는 것 입니다."
    },
    {
        "질문": "귀납적 논리와 연역적 논리의 차이점을 설명해주시겠습니까?",
        "답변": "귀납적 논리는 인덕션으로 사례에서 일반적인 규칙을 도출하는 것이고 연역적 논리는 디덕션으로 일반적인 규칙에서 결론을 도출하는 것입니다. 대표적인 예시로 인덕션에는 머신러닝이 있고 디덕션에는 삼단논법이 있습니다."
    },
    {
        "질문": "동전을 10번 던졌는데 앞면이 1번 나왔다. 공정성 테스트를 위한 귀무가설과 p값은 무엇인가요?",
        "답변": "귀무가설은 동전이 공정하다로 앞면이 나올 확률이 0.5인 것입니다. P값은 이항 분포 B(10, 0.5)에서 1번 이하로 나올 확률이므로 P값은 (1+10)x1024 = 0.011 정도 입니다. 유의수준 0.05에서 귀무가설을 기각하므로 동전은 불공정합니다."
    },
    {
        "질문": "1000번 동전을 던졌을 때 550번 앞면이 나왔다. 동전은 편향되었는가",
        "답변": "귀무가설은 동전이 공정하다로 앞면이 나올 확률이 0.5인 것입니다. 이항분포를 정규분포로 근사하면 n=1000, p=0.5 입니다. 이항분포에서 평균은 np로 500 이고 이항분포에서 시그마는 √np(1-p) 이므로 √250 이고 16정도 입니다. 중심으로부터 벗어난 거리 50을 시그마로 나누면 z score가 3이 넘으므로 동전은 공정하지 않습니다."
    },
    {
        "질문": "4보다 큰 숫자가 나올 때까지 주사위를 연속으로 굴렸는데 4번째에서 나오는 확률은 얼마이고, 4번째 미만의 시도에서 성공할 확률은 얼마인가요?",
        "답변": "한번에 성공할 확률은 2/6으로 1/3 입니다. 3번 모두 실패할 확률은 (2/3)^3 이므로 8/27 이고 마지막에 성공할 확률 1/3을 곱하면 8/81으로 약 0.1 입니다. 4번째 미만의 시도에서 성공할 확률은 1-0.1=0.9 입니다."
    },
    {
        "질문": "주사위가 두번 연속으로 5가 나올때까지 굴릴 때 예상되는 굴리는 횟수는 얼마인가요?",
        "답변": "한번에 성공할 확률은 (1/6)^2로 1/36 입니다. 따라서 예상 횟수는 1/p로 36회 입니다."
    },
    {
        "질문": "두 게임 중에 무엇이 더 유리한가. 게임1: 한번에 두개 주사위를 던져 두 값의 곱에 해당하는 달러를 가진다. 게임2: 하나의 주사위를 던져 값의 제곱에 해당하는 달러를 가진다.",
        "답변": "주사위의 모든 눈 수의 합은 7*3인 21이고 면이 6개 이므로 기댓값은 21/6=7/2 입니다. 게임 1은 기댓값 두개를 곱하는 것이므로 약 49/4=12 입니다. 게임 2는 1+4+9+...+36=91에 6을 나눈 값으로 약 91/6=15 입니다. 따라서 게임2가 더 유리합니다."
    },
    {
        "질문": "사용자의 80%가 60%의 영화에 좋아요를 누르고 사용자의 20%는 모든 영화에 좋아요를 누르는 'lazy user'이다. 누군가 연속으로 3개 영화에 좋아요를 눌렀다면 'lazy user'일 확률은 얼마나 되는가",
        "답변": "베이즈 정리를 사용하여 계산합니다. P(Lazy)=0.2, P(3likes|Lazy)=1, P(3likes|Unlazy)=0.6^3=0.2 입니다. P(Lazy|3likes) = P(3likes|Lazy)xP(Lazy)/P(3likes) 이므로 P(3likes)를 구해야합니다. P(3likes) = P(3likes|Lazy)xP(Lazy) + P(3likes|Unlazy)xP(Unlazy)로 구할 수 있습니다."
    },
    {
        "질문": "AB 테스트에 대하여 설명해주시겠습니까?",
        "답변": "두 가지 버전(A와 B)을 무작위로 사용자에게 보여주고 어떤 버전이 더 효과적인지 통계적 유의성을 검증하여 의사결정에 활용하는 방법입니다."
    },
    {
        "질문": "EDA가 중요한 이유를 설명해주시겠습니까?",
        "답변": "데이터의 특성, 패턴, 이상치를 파악하여 더 나은 의사결정을 할 수 있게 해주기 때문입니다. 데이터 전처리 방향과 분석 방법을 선택하는 데 도움을 줍니다."
    },
    {
        "질문": "좋은 feature란 무엇이고 판단하는 방법을 설명해주시겠습니까?",
        "답변": "좋은 feature는 타겟 변수와 높은 상관관계가 있고, 다른 feature들과는 낮은 상관관계를 가지는 feature 입니다."
    },
    {
        "질문": "NoSQL과 RDBMS의 차이점을 설명해주시겠습니까?",
        "답변": "NoSQL은 유연한 스키마를 가지고 있어 대용량 데이터 처리에 적합하며 수평적 확장이 용이합니다. (=몽고DB, 카산드라) RDBMS는 정형화된 스키마와 관계를 중시하며, 데이터 일관성을 보장합니다. (=MySQL)"
    },
    {
        "질문": "window 함수에 대하여 설명해주시겠습니까?",
        "답변": "행과 행 간의 관계를 정의하여 연산하는 함수입니다. 랭킹 함수, 집계 함수 등이 있으며 partition by로 그룹을 나누고 order by로 정렬을 할 수 있습니다."
    },
    {
        "질문": "MySQL에 대량의 데이터를 insert 하는 방법을 설명해주시겠습니까?",
        "답변": "LOAD DATA INFILE을 사용하여 csv 파일을 로드하거나 여러 insert를 하나의 트랜잭션으로 묶어서 처리하면 됩니다."
    },
    {
        "질문": "쿼리 성능을 확인하는 쿼리문은 무엇인가요?",
        "답변": "SHOW PROFILE을 사용해 쿼리의 실행 시간과 리소스 사용량을 확인할 수 있습니다. EXPLAIN을 사용하면 실행 계획을 자세하게 볼 수 있습니다."
    },
    {
        "질문": "MySQL이 느릴 때 가장 먼저 보는 것인 무엇인가요?",
        "답변": "slow_query_log 설정을 켜서 넥이 되는 쿼리를 확인합니다. 또한 EXPLAIN으로 쿼리의 성능을 확인하고 CPU나 메모리의 상태를 확인합니다."
    },
    {
        "질문": "동작하고 있는 MySQL을 백업하는 방법은 무엇인가요?",
        "답변": "DB가 작을 경우 논리적 백업으로 mysqldump를 하고 DB가 클 경우 물리적 백업으로 XtraBackup를 사용하면 됩니다."
    },
    {
        "질문": "Tableau를 사용하는 이유를 설명해주시겠습니까?",
        "답변": "대시보드 제작이 쉽고 빠르기 때문입니다. 상호작용이 가능한 그래프를 그릴 수 있고 실시간으로 데이터를 업데이트할 수 있는 장점이 있습니다."
    },
    {
        "질문": "4가지 이상의 정보를 시각화하는 방법을 설명해주시겠습니까?",
        "답변": "다차원 플랏을 설계하면 됩니다. 예를들어 뒤에 낮은 투명도로 막대 그래프를 그리고 위에 산점도 그래프를 그립니다. 산점도의 모양, 크기, 색깔을 통해서 차원을 더 추가할 수 있습니다."
    },
    {
        "질문": "파이차트가 좋지 않은 이유를 설명해주시겠습니까?",
        "답변": "각도나 면적 비교가 어려워서 정확한 비교가 어렵습니다. 특히 비슷한 크기의 조각이 있으면 정확한 숫자를 표시해야 누가 더 큰지 알 수 있습니다."
    },
    {
        "질문": "hadoop과 spark의 차이를 설명해주시겠습니까?",
        "답변": "하둡은 디스크 기반이고 스파크는 메모리기반 입니다. 그래서 스파크는 속도가 더 빠르고 실시간 처리가 가능하고 하둡은 배치 처리에 특화되어 있습니다."
    },
    {
        "질문": "MapReduce에 대하여 설명해주시겠습니까?",
        "답변": "대용량 데이터 처리를 위한 분산 프로그래밍 모델입니다. 키-벨류 쌍을 생성하는 맵 단계, 맵 단계의 중간 결과를 전송하는 셔플 단계, 그룹화된 데이터를 처리해 최종 결과를 계산하는 리듀스 단계로 진행됩니다."
    },
    {
        "질문": "잘 만들어지는 MapReduce는 무엇인가요?",
        "답변": "특정 파티션이나 키에 집중되는 데이터 스큐 현상이 없고 네트워크 부하를 발생시키는 셔플링이 최소화된 경우 입니다. 맵 단계에서 최대한 데이터를 필터링한 뒤에 최대한 작은 양의 데이터를 가지고 리듀스 작업을 하는 것이 좋습니다."
    },
    {
        "질문": "MapReduce 중간에 fail이 나는 것을 어떻게 모니터링 하는가",
        "답변": "YARN log -applicationId 나 JobTracker를 통해서 모니터링할 수 있습니다."
    },
    {
        "질문": "분산환경의 join은 (디스크, CPU, 네트워크) 중 어디서 병목이 일어나고 해결방법은 무엇인가요?",
        "답변": "주로 네트워크에서 병목현상이 발생합니다. 데이터 셔플링을 할 때 네트워크의 부하가 큽니다. 브로드캐스트 조인이나 버킷팅으로 개선할 수 있습니다."
    },
    {
        "질문": "암달의 법칙을 설명하고 shared-nothing 구조를 설명해주시겠습니까?",
        "답변": "암달의 법칙은 병렬화로 얻을 수 있는 최대 성능 향상을 계산하는 법칙 입니다. shared-nothing 구조는 노드 간에 리소스를 공유하지 않는 아키텍처를 말하며 독립적인 리소스를 가지므로 네트워크 부하를 최소화 합니다."
    },
    {
        "질문": "shared-nothing의 장단점을 설명해주시겠습니까?",
        "답변": "장점은 확장성이 높고 리소스간에 경쟁이 발생하지 않는 것이고 단점은 데이터 정합성 관리가 어렵고 노드 간 통신에서 부하가 발생할 수 있는 것입니다."
    },
    {
        "질문": "대용량 자료를 빠르게 lookup하기 위한 백엔드는 무엇인가요?",
        "답변": "Redis 같은 인메모리 DB가 좋습니다. 키-벨류 구조로 빠른 검색이 가능하기 때문입니다."
    },
    {
        "질문": "Apache 보다 Nginx가 성능이 좋은 이유를 설명해주시겠습니까?",
        "답변": "이벤트 기반 처리 방식으로 메모리를 적게 사용하고 동시 접속도 잘 처리하기 때문입니다. 아파치는 프로세스 기반이라 리소스를 많이 사용합니다."
    },
    {
        "질문": "node.js는 빠르지만 사용하면 안되는 경우를 설명해주시겠습니까?",
        "답변": "node.js는 CPU 집약적 계산을 목적으로 만든 언어가 아니며 싱글 스레드이기 때문에 계산 시간이 오래걸리면 다른 요청이 모두 막히기 때문입니다."
    },
    {
        "질문": "파이썬의 특징에 대해 설명해주시겠습니까?",
        "답변": "파이썬은 인터프리터 언어입니다. 코드를 작성한 후 컴파일 없이 즉시 실행할 수 있습니다. 가독성이 높은 특징이 있고 머신러닝과 데이터 분석과 같은 다양한 분야에서 사용됩니다."
    },
    {
        "질문": "인터프리터와 컴파일러의 차이를 설명해주시겠습니까?",
        "답변": "인터프리터는 소스 코드의 내용을 한번에 한줄씩 읽어들여서 실행합니다. 소스 코드를 해석하는데는 적은 시간이 걸리지만 실행 시간은 느립니다. 컴파일러는 전체 프로그램 코드를 스캔하여 소스 코드(하이 레벨 프로그래밍 언어)를 오브젝트 코드(로우 레벨 프로그래밍 언어)로 바꾸어주는 역할을 합니다. 컴파일러는 소스코드를 해석하는데는 많은 시간이 걸리지만 한번 오브젝트 코드로 바꿔놓으면 실행 시간은 빠릅니다."
    },
    {
        "질문": "파이썬 데코레이터, 제너레이터, 이터레이터의 개념과 사용 예시를 설명해주시겠습니까?",
        "답변": "데코레이터는 기존 함수의 코드를 수정하지 않고 앞뒤에 기능을 추가하고 싶을 때 사용하는 문법(@)입니다. 함수를 인자로 받아 새로운 함수를 반환하는 고차 함수 입니다. (파이토치 @torch.no_grad()) 제너레이터는 이터레이터를 생성하는 함수입니다. 일반 함수와 달리 return 대신 `yield` 를 사용합니다. 호출 시 함수의 실행을 일시 중지하고 값을 반환하며, 다음 호출 시 멈춘 지점부터 다시 실행됩니다. (파이토치 IterableDataset) 이터레이터는 `__next__` 메서드를 통해 데이터를 순차적으로 하나씩 꺼낼 수 있는 객체입니다. 리스트와 달리 모든 데이터를 메모리에 올리지 않고 현재 순서의 데이터만 다룹니다. (파이토치 DataLoader)"
    },
    {
        "질문": "리스트와 튜플의 공통점과 차이점을 설명해주시겠습니까?",
        "답변": "공통점으로는 둘 다 여러 데이터를 담을 수 있는 컨테이너형 변수입니다. 그리고 인덱스를 통해 특정 요소에 접근할 수 있으며, iterable 합니다. 차이점으로는 리스트는 mutable 하지만 튜플은 immutable 합니다. 수정할 수 없는 특징 때문에 리스트는 딕셔너리의 키 값으로 사용 불가능 하지만, 튜플은 사용 가능합니다. 또한 같은 개수의 for 문을 돌리면 튜플이 리스트보다 속도가 빠릅니다. 리스트는 객체가 생성된 후 크기 확장을 대비해 추가 메모리를 할당하지만 튜플은 크기가 고정적이기 때문에 최소 메모리만 할당하기 때문입니다."
    },
    {
        "질문": "파이썬의 메모리 할당 방법을 설명해주시겠습니까?",
        "답변": "프라이빗 힙: 모든 객체와 자료구조를 저장하는 공간입니다. 프로그래머가 직접 접근할 수 없으며 파이썬 메모리 관리자가 관리합니다. 레퍼런스 카운팅: 객체를 참조하는 변수의 수를 세어, 참조 횟수가 0이 되면 즉시 메모리를 해제합니다. 가비지 컬렉션: 순환 참조 문제를 해결하기 위해, 주기적으로 세대별 가비지 컬렉터가 작동하여 메모리를 정리합니다."
    },
    {
        "질문": "파이썬 리스트와 딕셔너리의 차이를 설명해주시겠습니까?",
        "답변": "리스트는 순서가 있는 시퀀스(Sequence) 자료형으로 인덱스를 통해 값에 접근합니다. (시간복잡도 O(n)) 딕셔너리는 키(Key)와 값(Value)의 쌍으로 이루어진 해시 테이블(Hash Table) 구조입니다. (시간복잡도 O(1))"
    },
    {
        "질문": "해시 테이블(Hash Table)의 원리와 시간 복잡도를 설명해주시겠습니까?",
        "답변": "해시 테이블은 Key를 해시 함수(Hash Function)에 넣어 얻은 인덱스에 Value를 저장하는 구조입니다. Python의 dict가 이 구조이며, 평균적으로 O(1)의 시간 복잡도로 데이터를 조회할 수 있습니다. AI 분야에서는 거대한 임베딩 테이블(Embedding Table)을 조회하거나, 데이터를 빠르게 로딩할 때 필수적으로 사용됩니다."
    },
    {
        "질문": "배열 연산에서 'Vectorization(벡터화)'를 설명해주시겠습니까?",
        "답변": "Vectorization은 루프(for문)를 사용하지 않고 배열 전체에 대해 한 번에 연산을 수행하는 기법입니다. (NumPy, PyTorch 등) 기존 프로그래밍처럼 for문을 돌리는게 아니라 numpy나 tensor를 사용하면 속도가 훨씬 빠릅니다."
    },
    {
        "질문": "동시에 10개 컴퓨터에 라이브러리를 설치하는 번거로움을 해결하는 방법을 설명해주시겠습니까?",
        "답변": "requirements.txt나 environment.yml 파일을 작성하여 버전 호환성을 맞추고, 이를 쉘 스크립트로 일괄 실행하여 설치를 진행합니다. 만약 OS와 CUDA 버전 문제가 있다면 도커 이미지를 만들어 도커 허브에 올린 뒤 도커 풀을 하는 방법도 있습니다."
    },
    {
        "질문": "프로세스(Process)와 스레드(Thread)의 차이를 설명해주시겠습니까?",
        "답변": "프로세스는 운영체제로부터 독립된 메모리 공간을 할당받는 실행 단위입니다. 스레드는 한 프로세스 내에서 메모리(Stack 제외)를 공유하는 실행 단위입니다. AI 학습 시 GPU 연산은 비동기적으로 처리되지만, 데이터 전처리와 로딩은 CPU에서 이루어집니다. 이때 프로세스 간 통신 비용(IPC)과 스레드 간 공유 메모리의 이점을 고려하여 데이터 파이프라인을 설계해야 합니다."
    },
    {
        "질문": "GIL(Global Interpreter Lock)에 대해 설명하고, 이것이 AI 학습(Dataloader)에 미치는 영향을 설명해주시겠습니까?",
        "답변": "GIL은 파이썬 인터프리터가 한 번에 하나의 스레드만 바이트코드를 실행하도록 잠그는 기능입니다. 이 때문에 파이썬에서는 멀티 스레드를 써도 CPU 연산 병렬 처리가 불가능합니다. 이는 파이썬의 치명적인 단점 입니다. PyTorch DataLoader에서 num_workers를 설정할 때 멀티 스레드가 아닌 멀티 프로세싱을 사용하는 근본적인 이유가 GIL 때문입니다. 멀티 프로세싱은 각 프로세스가 독립된 메모리 공간을 가지므로 GIL의 영향을 받지 않고 병렬 처리가 가능합니다. 두괄식으로 말하기 내가 가진 경험, 역량, 소프트 스킬과 연계 경험 목록 석사 논문의 딥러닝 설계 멀티 GPU 리눅스 서버 모델링 직무 준비 과정 LGD 애플워치 자동검사 데이터분석 프로젝트 논문 리뷰 블로그 역량 목록 AI 모델링 도메인 지식 활용 AI 모델 숙련도 수학적 이해와 통계적 지식 논문 리서치 AI 모델 트렌드 소프트 스킬 목록 문제해결력 창의성 커뮤니케이션 스토리텔링 자기주도적 성장 의지"
    },
    {
        "질문": "데이터 사이언티스트의 역할과 책임에 대해 설명해주세요.",
        "답변": "데이터 사이언티스트는 대량의 데이터를 수집, 분석하여 비즈니스 인사이트를 도출하는 역할을 합니다. 통계, 머신러닝, 프로그래밍 기술을 활용하여 데이터 기반 의사결정을 지원하며, 예측 모델 개발, A/B 테스트 설계, 데이터 시각화 등의 업무를 수행합니다."
    },
    {
        "질문": "지도 학습과 비지도 학습의 차이점은 무엇인가요?",
        "답변": "지도 학습은 레이블이 있는 데이터로 학습하여 예측 모델을 만드는 방법으로, 분류와 회귀가 대표적입니다. 비지도 학습은 레이블 없이 데이터의 패턴을 찾는 방법으로, 군집화와 차원 축소가 있습니다."
    },
    {
        "질문": "과적합(Overfitting)이란 무엇이며, 어떻게 방지할 수 있나요?",
        "답변": "과적합은 모델이 훈련 데이터에 지나치게 맞춰져 새로운 데이터에 대한 성능이 떨어지는 현상입니다. 정규화(L1, L2), 교차 검증, 드롭아웃, 조기 종료, 데이터 증강 등으로 방지할 수 있습니다."
    },
    {
        "질문": "결정 트리와 랜덤 포레스트의 차이점을 설명해주세요.",
        "답변": "결정 트리는 단일 트리로 데이터를 분류하는 모델이나 과적합 가능성이 높습니다. 랜덤 포레스트는 여러 개의 결정 트리를 앙상블하여 예측의 분산을 줄이고 일반화 성능을 향상시킨 모델입니다."
    },
    {
        "질문": "정밀도(Precision)와 재현율(Recall)의 차이는 무엇인가요?",
        "답변": "정밀도는 양성으로 예측한 것 중 실제 양성의 비율(TP/(TP+FP))이며, 재현율은 실제 양성 중 정확히 예측한 비율(TP/(TP+FN))입니다. 정밀도는 거짓 양성을, 재현율은 거짓 음성을 줄이는 데 중점을 둡니다."
    },
    {
        "질문": "교차 검증(Cross Validation)이 왜 중요한가요?",
        "답변": "교차 검증은 데이터를 여러 개의 폴드로 나누어 모델을 반복 학습하고 평가하여 모델의 일반화 성능을 신뢰성 있게 측정합니다. 데이터 분할의 편향을 줄이고 과적합을 방지하는 데 도움이 됩니다."
    },
    {
        "질문": "Feature Engineering이란 무엇이며 왜 중요한가요?",
        "답변": "Feature Engineering은 원시 데이터로부터 모델 성능을 향상시킬 수 있는 새로운 특징을 생성하거나 기존 특징을 변환하는 과정입니다. 모델의 예측력을 크게 향상시킬 수 있어 매우 중요합니다."
    },
    {
        "질문": "Gradient Boosting과 XGBoost의 차이점을 설명해주세요.",
        "답변": "Gradient Boosting은 순차적으로 약한 학습기를 추가하며 이전 모델의 오차를 보정하는 앙상블 기법입니다. XGBoost는 Gradient Boosting의 최적화된 구현체로, 병렬 처리, 정규화, 결측치 처리 등의 기능을 추가하여 속도와 성능을 개선했습니다."
    },
    {
        "질문": "불균형 데이터셋을 다루는 방법에는 어떤 것들이 있나요?",
        "답변": "오버샘플링(SMOTE), 언더샘플링, 클래스 가중치 조정, 앙상블 기법(EasyEnsemble), 평가 지표 변경(F1-score, AUC-ROC), Focal Loss 사용 등의 방법이 있습니다."
    },
    {
        "질문": "차원의 저주(Curse of Dimensionality)란 무엇인가요?",
        "답변": "차원의 저주는 특징의 수가 증가할수록 데이터 공간이 급격히 커져 필요한 데이터량이 기하급수적으로 증가하는 현상입니다. 이는 모델의 성능 저하와 과적합을 초래할 수 있습니다."
    },
    {
        "질문": "A/B 테스트를 설계할 때 고려해야 할 주요 요소는 무엇인가요?",
        "답변": "충분한 샘플 크기, 무작위 할당, 통계적 유의성 수준 설정, 테스트 기간, 세그먼트별 분석, 외부 변수 통제, 다중 검정 문제 고려 등이 있습니다."
    },
    {
        "질문": "시계열 데이터 분석에서 정상성(Stationarity)이 왜 중요한가요?",
        "답변": "많은 시계열 모델(ARIMA 등)은 정상성을 가정하기 때문입니다. 정상성은 평균, 분산, 자기공분산이 시간에 따라 일정함을 의미하며, 차분, 로그 변환 등으로 달성할 수 있습니다."
    },
    {
        "질문": "딥러닝에서 Batch Normalization의 역할은 무엇인가요?",
        "답변": "Batch Normalization은 각 레이어의 입력을 정규화하여 내부 공변량 변화를 줄이고, 학습 속도를 높이며, 높은 학습률 사용을 가능하게 하고, 정규화 효과로 일반화 성능을 향상시킵니다."
    },
    {
        "질문": "추천 시스템에서 협업 필터링과 콘텐츠 기반 필터링의 차이는?",
        "답변": "협업 필터링은 사용자 간 유사도나 아이템 간 유사도를 기반으로 추천하며, 콘텐츠 기반 필터링은 아이템의 특징을 분석하여 사용자 선호도와 매칭합니다. 하이브리드 방식도 많이 사용됩니다."
    },
    {
        "질문": "모델 해석 가능성을 높이는 방법에는 어떤 것들이 있나요?",
        "답변": "SHAP, LIME, Feature Importance, Partial Dependence Plots, 단순 모델 사용(선형 회귀, 결정 트리), Attention Mechanism, Saliency Maps 등의 기법을 활용할 수 있습니다."
    },
    {
        "질문": "SQL과 NoSQL 데이터베이스의 차이점은 무엇인가요?",
        "답변": "SQL은 관계형 데이터베이스로 정형 데이터, ACID 특성, 스키마 기반입니다. NoSQL은 비정형 데이터 처리에 유리하며, 수평 확장이 용이하고, 유연한 스키마를 가집니다."
    },
    {
        "질문": "데이터 분석 프로젝트의 일반적인 프로세스를 설명해주세요.",
        "답변": "1) 문제 정의 및 목표 설정, 2) 데이터 수집, 3) 데이터 전처리 및 탐색적 데이터 분석(EDA), 4) 가설 수립, 5) 분석 및 모델링, 6) 결과 해석 및 시각화, 7) 인사이트 도출 및 보고서 작성 순으로 진행됩니다."
    },
    {
        "질문": "탐색적 데이터 분석(EDA)에서 주로 수행하는 작업은 무엇인가요?",
        "답변": "기술 통계량 확인, 데이터 분포 파악, 결측치 및 이상치 탐지, 변수 간 상관관계 분석, 데이터 시각화(히스토그램, 박스플롯, 산점도 등)를 수행합니다."
    },
    {
        "질문": "평균, 중앙값, 최빈값 중 언제 어떤 지표를 사용해야 하나요?",
        "답변": "평균은 정규 분포에서 유용하나 이상치에 민감합니다. 중앙값은 이상치가 있거나 치우친 분포에서 적합하며, 최빈값은 범주형 데이터나 다중 모드 분포에서 사용합니다."
    },
    {
        "질문": "상관관계와 인과관계의 차이는 무엇인가요?",
        "답변": "상관관계는 두 변수 간 통계적 연관성을 의미하며, 인과관계는 한 변수가 다른 변수에 직접적인 영향을 미치는 관계입니다. 상관관계가 있다고 인과관계가 있는 것은 아닙니다."
    },
    {
        "질문": "데이터 정규화(Normalization)와 표준화(Standardization)의 차이는?",
        "답변": "정규화는 데이터를 0과 1 사이로 스케일링하며(Min-Max Scaling), 표준화는 평균을 0, 표준편차를 1로 변환합니다(Z-score). 이상치 영향도와 사용 목적에 따라 선택합니다."
    },
    {
        "질문": "Cohort 분석이란 무엇이며 어떻게 활용하나요?",
        "답변": "Cohort 분석은 특정 시점이나 특성을 공유하는 그룹을 시간에 따라 추적 분석하는 방법입니다. 사용자 유지율, 이탈률, LTV 분석 등에 활용되며, 마케팅 효과를 측정하는 데 유용합니다."
    },
    {
        "질문": "RFM 분석에 대해 설명해주세요.",
        "답변": "RFM은 Recency(최근성), Frequency(빈도), Monetary(금액)를 기준으로 고객을 세분화하는 기법입니다. 고객의 가치를 평가하고 맞춤형 마케팅 전략을 수립하는 데 활용됩니다."
    },
    {
        "질문": "Funnel 분석의 목적과 활용 방법은 무엇인가요?",
        "답변": "Funnel 분석은 사용자가 전환 과정의 각 단계를 거치는 비율을 분석하여 이탈 지점을 파악합니다. 웹사이트 전환율 개선, 구매 프로세스 최적화 등에 활용됩니다."
    },
    {
        "질문": "데이터 시각화에서 적절한 차트 유형을 선택하는 기준은?",
        "답변": "분석 목적에 따라 다릅니다. 비교는 막대 차트, 추세는 선 차트, 분포는 히스토그램, 관계는 산점도, 구성은 파이 차트, 지리적 분포는 지도 차트를 사용합니다."
    },
    {
        "질문": "대시보드 설계 시 고려해야 할 핵심 원칙은 무엇인가요?",
        "답변": "명확한 목적 정의, 핵심 지표(KPI) 우선 배치, 시각적 계층 구조, 일관된 디자인, 실시간 업데이트, 드릴다운 기능, 모바일 호환성, 사용자 피드백 반영 등을 고려해야 합니다."
    },
    {
        "질문": "통계적 유의성(Statistical Significance)이란 무엇인가요?",
        "답변": "통계적 유의성은 관찰된 결과가 우연히 발생할 확률이 매우 낮아 실제 효과가 있다고 판단할 수 있는 수준을 의미합니다. 일반적으로 p-value < 0.05를 기준으로 합니다."
    },
    {
        "질문": "Type I 오류와 Type II 오류의 차이는 무엇인가요?",
        "답변": "Type I 오류는 귀무가설이 참인데 기각하는 오류(거짓 양성)이며, Type II 오류는 귀무가설이 거짓인데 기각하지 못하는 오류(거짓 음성)입니다."
    },
    {
        "질문": "시계열 데이터에서 추세, 계절성, 잔차를 어떻게 분해하나요?",
        "답변": "시계열 분해(Decomposition)를 사용하여 관찰값을 추세(Trend), 계절성(Seasonality), 잔차(Residual)로 분리합니다. 가법 모델과 승법 모델이 있으며, STL 분해 등의 기법을 활용합니다."
    },
    {
        "질문": "데이터 품질 관리를 위해 확인해야 할 주요 항목은?",
        "답변": "정확성(Accuracy), 완전성(Completeness), 일관성(Consistency), 적시성(Timeliness), 유효성(Validity), 유일성(Uniqueness)을 확인하고 데이터 프로파일링과 품질 메트릭을 모니터링해야 합니다."
    },
    {
        "질문": "ETL과 ELT의 차이점은 무엇인가요?",
        "답변": "ETL은 Extract-Transform-Load 순서로 데이터를 추출 후 변환하여 적재합니다. ELT는 Extract-Load-Transform으로 먼저 적재 후 변환하며, 클라우드 데이터 웨어하우스의 강력한 처리 능력을 활용합니다."
    },
    {
        "질문": "데이터 파이프라인이란 무엇이며 왜 필요한가요?",
        "답변": "데이터 파이프라인은 데이터를 소스에서 목적지로 자동화된 흐름으로 이동시키는 프로세스입니다. 데이터 수집, 변환, 적재를 자동화하여 효율성과 신뢰성을 높입니다."
    },
    {
        "질문": "Apache Spark와 Hadoop의 차이점을 설명해주세요.",
        "답반": "Hadoop은 배치 처리에 최적화된 분산 파일 시스템(HDFS)과 MapReduce를 사용합니다. Spark는 인메모리 처리로 속도가 빠르며, 배치, 스트리밍, 머신러닝 등 다양한 작업을 지원합니다."
    },
    {
        "질문": "데이터 웨어하우스와 데이터 레이크의 차이는 무엇인가요?",
        "답변": "데이터 웨어하우스는 정형 데이터를 구조화된 스키마로 저장하며 분석에 최적화되어 있습니다. 데이터 레이크는 정형/비정형 모든 데이터를 원시 형태로 저장하며 유연성이 높습니다."
    },
    {
        "질문": "배치 처리와 스트리밍 처리의 차이점은 무엇인가요?",
        "답변": "배치 처리는 일정량의 데이터를 모아 주기적으로 처리하며 지연 시간이 길지만 처리량이 높습니다. 스트리밍 처리는 실시간으로 데이터를 처리하여 지연 시간이 짧지만 복잡도가 높습니다."
    },
    {
        "질문": "데이터 파티셔닝(Partitioning)의 목적과 효과는 무엇인가요?",
        "답변": "데이터를 논리적으로 분할하여 쿼리 성능을 향상시키고, 관리 효율성을 높이며, 병렬 처리를 가능하게 합니다. 날짜, 지역, 카테고리 등으로 파티셔닝할 수 있습니다."
    },
    {
        "질문": "CDC(Change Data Capture)란 무엇이며 어떻게 활용하나요?",
        "답변": "CDC는 데이터베이스의 변경 사항(INSERT, UPDATE, DELETE)을 감지하고 추적하는 기술입니다. 실시간 데이터 동기화, 증분 데이터 로드, 이벤트 기반 아키텍처에 활용됩니다."
    },
    {
        "질문": "데이터 파이프라인의 오류 처리 및 복구 전략은?",
        "답변": "재시도 메커니즘, 데드레터 큐, 체크포인트, 멱등성 보장, 로깅 및 모니터링, 알림 시스템, 롤백 기능을 구현하여 장애에 대응합니다."
    },
    {
        "질문": "Apache Airflow의 DAG란 무엇인가요?",
        "답변": "DAG(Directed Acyclic Graph)는 방향성 비순환 그래프로, 작업 간 의존성과 실행 순서를 정의합니다. Airflow에서 워크플로우를 코드로 정의하고 스케줄링하는 핵심 개념입니다."
    },
    {
        "질문": "데이터 품질 검증을 파이프라인에 통합하는 방법은?",
        "답변": "스키마 검증, 데이터 프로파일링, 이상치 탐지, 완전성 체크, 중복 확인 등을 파이프라인 단계에 포함시키고, Great Expectations 같은 도구를 활용합니다."
    },
    {
        "질문": "Lambda Architecture와 Kappa Architecture의 차이는?",
        "답변": "Lambda는 배치 레이어와 스피드 레이어를 병행하여 정확성과 실시간성을 모두 제공합니다. Kappa는 스트리밍만 사용하여 아키텍처를 단순화하지만 재처리가 어렵습니다."
    },
    {
        "질문": "BI 도구의 주요 기능에는 어떤 것들이 있나요?",
        "답변": "데이터 연결 및 통합, 데이터 모델링, 대시보드 및 리포트 생성, 셀프 서비스 분석, 드릴다운/슬라이싱/다이싱, 알림 및 스케줄링, 협업 기능이 있습니다."
    },
    {
        "질문": "Tableau와 Power BI의 주요 차이점은 무엇인가요?",
        "답변": "Tableau는 강력한 시각화와 직관적인 인터페이스가 장점이며, Power BI는 Microsoft 생태계와의 통합, 저렴한 비용, DAX를 통한 고급 계산이 장점입니다."
    },
    {
        "질문": "OLAP과 OLTP의 차이점을 설명해주세요.",
        "답변": "OLTP(Online Transaction Processing)는 일상적인 트랜잭션 처리에 최적화되어 있고, OLAP(Online Analytical Processing)은 복잡한 분석 쿼리에 최적화되어 있으며 다차원 데이터 분석을 지원합니다."
    },
    {
        "질문": "Star Schema와 Snowflake Schema의 차이는 무엇인가요?",
        "답변": "Star Schema는 정규화되지 않은 차원 테이블로 쿼리가 단순하고 빠릅니다. Snowflake Schema는 차원 테이블을 정규화하여 저장 공간을 절약하지만 조인이 복잡합니다."
    },
    {
        "질문": "KPI(핵심 성과 지표)를 설정할 때 고려사항은 무엇인가요?",
        "답변": "SMART 원칙(Specific, Measurable, Achievable, Relevant, Time-bound)을 따르고, 비즈니스 목표와 연계, 측정 가능성, 이해관계자 합의, 정기적인 검토가 필요합니다."
    },
    {
        "질문": "데이터 거버넌스가 BI에서 왜 중요한가요?",
        "답변": "데이터 품질, 보안, 개인정보 보호, 일관성을 보장하고, 신뢰할 수 있는 인사이트를 제공하며, 규제 준수를 가능하게 하여 BI의 가치를 극대화합니다."
    },
    {
        "질문": "셀프 서비스 BI의 장점과 단점은 무엇인가요?",
        "답변": "장점은 빠른 인사이트 도출, IT 부담 감소, 사용자 자율성 증가입니다. 단점은 데이터 품질 문제, 중복 작업, 거버넌스 어려움, 교육 필요성입니다."
    },
    {
        "질문": "Drill-down과 Drill-up의 차이는 무엇인가요?",
        "답변": "Drill-down은 요약된 데이터에서 상세 데이터로 이동하는 것이고(년→월→일), Drill-up은 상세 데이터에서 요약 데이터로 이동하는 것입니다(일→월→년)."
    },
    {
        "질문": "DAX(Data Analysis Expressions)란 무엇인가요?",
        "답변": "DAX는 Power BI, Excel 등에서 사용하는 수식 언어로, 계산 열, 측정값, 테이블을 만들어 복잡한 비즈니스 로직과 분석을 수행할 수 있게 합니다."
    },
    {
        "질문": "데이터 모델링에서 Fact Table과 Dimension Table의 역할은?",
        "답변": "Fact Table은 측정 가능한 수치 데이터(매출, 수량 등)를 저장하고, Dimension Table은 분석 맥락을 제공하는 설명 데이터(날짜, 제품, 고객 등)를 저장합니다."
    },
    {
        "질문": "BI 대시보드 성능 최적화 방법은 무엇인가요?",
        "답변": "데이터 사전 집계, 인덱싱, 캐싱, 증분 업데이트, 불필요한 계산 제거, 시각화 개수 제한, 필터 최적화, 데이터 모델 단순화를 통해 최적화합니다."
    },
    {
        "질문": "실시간 대시보드 구축 시 고려사항은 무엇인가요?",
        "답변": "데이터 레이턴시, 업데이트 빈도, 시스템 부하, 동시 사용자 수, 데이터 소스 성능, 캐싱 전략, 알림 메커니즘을 고려해야 합니다."
    },
    {
        "질문": "BI 프로젝트의 ROI를 측정하는 방법은?",
        "답변": "의사결정 속도 개선, 리포트 생성 시간 단축, 데이터 접근성 향상, 오류 감소, 매출 증가, 비용 절감 등을 정량화하여 투자 대비 효과를 측정합니다."
    },
    {
        "질문": "데이터베이스 정규화란 무엇이며 왜 필요한가요?",
        "답변": "데이터 중복을 최소화하고 무결성을 보장하기 위해 테이블을 구조화하는 과정입니다. 1NF부터 5NF까지 있으며, 이상 현상을 방지하고 유지보수를 용이하게 합니다."
    },
    {
        "질문": "ACID 속성에 대해 설명해주세요.",
        "답변": "Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성)의 약자로, 데이터베이스 트랜잭션의 안전성을 보장하는 핵심 속성입니다."
    },
    {
        "질문": "인덱스(Index)의 역할과 종류를 설명해주세요.",
        "답변": "인덱스는 데이터 검색 속도를 향상시키는 자료구조입니다. B-Tree, Hash, Bitmap, Full-text 등의 종류가 있으며, SELECT 성능을 높이지만 INSERT/UPDATE/DELETE는 느려질 수 있습니다."
    },
    {
        "질문": "트랜잭션 격리 수준(Isolation Level)에 대해 설명해주세요.",
        "답변": "Read Uncommitted, Read Committed, Repeatable Read, Serializable 4단계가 있으며, 격리 수준이 높을수록 일관성은 높아지지만 동시성은 낮아집니다."
    },
    {
        "질문": "파티셔닝과 샤딩의 차이점은 무엇인가요?",
        "답변": "파티셔닝은 하나의 데이터베이스 내에서 테이블을 분할하는 것이고, 샤딩은 여러 데이터베이스 서버에 데이터를 분산하여 수평적 확장을 실현합니다."
    },
    {
        "질문": "데드락(Deadlock)이란 무엇이며 어떻게 방지하나요?",
        "답변": "두 개 이상의 트랜잭션이 서로의 자원을 기다리며 무한 대기하는 상황입니다. 타임아웃 설정, 자원 순서 지정, 데드락 감지 및 복구 메커니즘으로 방지합니다."
    },
    {
        "질문": "리플리케이션(Replication)의 목적과 종류는 무엇인가요?",
        "답변": "데이터 가용성과 성능 향상을 위해 데이터를 여러 서버에 복제합니다. Master-Slave, Master-Master, 동기/비동기 리플리케이션 등이 있습니다."
    },
    {
        "질문": "쿼리 최적화를 위한 방법에는 어떤 것들이 있나요?",
        "답변": "적절한 인덱스 사용, SELECT * 피하기, WHERE 절 최적화, JOIN 순서 조정, 서브쿼리 대신 JOIN 사용, 실행 계획 분석, 통계 정보 업데이트 등이 있습니다."
    },
    {
        "질문": "백업과 복구 전략에는 어떤 것들이 있나요?",
        "답변": "전체 백업, 증분 백업, 차등 백업이 있으며, RPO(복구 시점 목표)와 RTO(복구 시간 목표)를 고려하여 전략을 수립하고 정기적으로 복구 테스트를 수행해야 합니다."
    },
    {
        "질문": "NoSQL 데이터베이스의 CAP 정리를 설명해주세요.",
        "답변": "Consistency(일관성), Availability(가용성), Partition tolerance(분할 내성) 중 최대 2가지만 보장할 수 있다는 이론입니다. 시스템 요구사항에 따라 트레이드오프를 선택합니다."
    },
    {
        "질문": "데이터베이스 성능 모니터링 시 주요 지표는 무엇인가요?",
        "답변": "쿼리 응답 시간, CPU/메모리 사용률, 디스크 I/O, 동시 연결 수, 트랜잭션 처리량, 락 대기 시간, 캐시 히트율 등을 모니터링합니다."
    },
    {
        "질문": "Connection Pool의 역할과 중요성은 무엇인가요?",
        "답변": "데이터베이스 연결을 미리 생성하고 재사용하여 연결 오버헤드를 줄이고 성능을 향상시킵니다. 적절한 풀 크기 설정이 중요합니다."
    },
    {
        "질문": "저장 프로시저(Stored Procedure)의 장단점은 무엇인가요?",
        "답변": "장점은 성능 향상, 네트워크 트래픽 감소, 보안 강화, 재사용성입니다. 단점은 디버깅 어려움, 버전 관리 복잡성, 특정 DBMS 종속성입니다."
    },
    {
        "질문": "DB 마이그레이션 시 고려사항은 무엇인가요?",
        "답변": "데이터 일관성 보장, 다운타임 최소화, 롤백 계획, 성능 테스트, 스키마 호환성, 애플리케이션 수정, 단계적 마이그레이션, 백업 및 복구 전략을 고려해야 합니다."
    },
    {
        "질문": "QA와 테스팅의 차이점은 무엇인가요?",
        "답변": "테스팅은 소프트웨어의 결함을 찾는 활동이고, QA(Quality Assurance)는 전체 개발 프로세스의 품질을 보장하는 더 광범위한 활동으로, 예방적 접근을 포함합니다."
    },
    {
        "질문": "블랙박스 테스트와 화이트박스 테스트의 차이는?",
        "답변": "블랙박스 테스트는 내부 구조를 모르는 상태에서 입출력만 검증하고, 화이트박스 테스트는 내부 코드 구조를 알고 로직과 경로를 테스트합니다."
    },
    {
        "질문": "단위 테스트, 통합 테스트, 시스템 테스트의 차이는?",
        "답변": "단위 테스트는 개별 컴포넌트를, 통합 테스트는 컴포넌트 간 상호작용을, 시스템 테스트는 전체 시스템의 기능을 검증합니다."
    },
    {
        "질문": "회귀 테스트(Regression Test)란 무엇인가요?",
        "답변": "코드 변경 후 기존 기능이 정상 작동하는지 확인하는 테스트입니다. 자동화를 통해 효율적으로 수행하며, CI/CD 파이프라인에 통합됩니다."
    },
    {
        "질문": "테스트 케이스 작성 시 고려사항은 무엇인가요?",
        "답변": "명확한 목적, 재현 가능성, 독립성, 경계값 테스트, 예외 상황, 우선순위, 유지보수 용이성, 명확한 예상 결과를 포함해야 합니다."
    },
    {
        "질문": "경계값 분석(Boundary Value Analysis)이란 무엇인가요?",
        "답변": "입력 값의 경계에서 오류가 발생하기 쉽다는 점을 이용해 최솟값, 최댓값, 그 직전/직후 값을 테스트하는 기법입니다."
    },
    {
        "질문": "동치 분할(Equivalence Partitioning)에 대해 설명해주세요.",
        "답변": "입력 데이터를 동일하게 처리되는 그룹으로 나누고 각 그룹에서 대표값을 선택하여 테스트하는 기법으로, 테스트 케이스 수를 줄입니다."
    },
    {
        "질문": "상태 전이 테스팅이란 무엇인가요?",
        "답변": "시스템의 상태 변화와 전이를 모델링하여 모든 상태와 전이 경로를 테스트하는 기법입니다. 상태 다이어그램을 기반으로 합니다."
    },
    {
        "질문": "부하 테스트, 스트레스 테스트, 성능 테스트의 차이는?",
        "답변": "부하 테스트는 예상 부하에서의 성능을, 스트레스 테스트는 한계 상황에서의 동작을, 성능 테스트는 응답 시간, 처리량 등 전반적인 성능을 측정합니다."
    },
    {
        "질문": "테스트 자동화의 장점과 단점은 무엇인가요?",
        "답변": "장점은 반복 테스트 효율성, 빠른 피드백, 회귀 테스트 용이성입니다. 단점은 초기 비용, 유지보수 부담, 모든 테스트를 자동화할 수 없다는 점입니다."
    },
    {
        "질문": "결함 우선순위와 심각도의 차이는 무엇인가요?",
        "답변": "심각도는 결함이 시스템에 미치는 영향의 정도이고, 우선순위는 결함 수정의 긴급도입니다. 심각도가 높아도 우선순위가 낮을 수 있습니다."
    },
    {
        "질문": "테스트 커버리지의 종류에는 어떤 것들이 있나요?",
        "답변": "구문 커버리지, 분기 커버리지, 조건 커버리지, 경로 커버리지, 함수 커버리지 등이 있으며, 높은 커버리지가 품질을 보장하지는 않습니다."
    },
    {
        "질문": "Smoke 테스트와 Sanity 테스트의 차이는?",
        "답변": "Smoke 테스트는 빌드의 기본 기능이 작동하는지 확인하는 초기 테스트이고, Sanity 테스트는 특정 기능이나 버그 수정이 제대로 되었는지 빠르게 확인하는 테스트입니다."
    },
    {
        "질문": "탐색적 테스팅(Exploratory Testing)이란 무엇인가요?",
        "답변": "사전에 정의된 테스트 케이스 없이 테스터가 시스템을 탐색하며 동시에 학습, 설계, 실행하는 테스팅 기법으로, 예상치 못한 결함을 찾는 데 유용합니다."
    },
    {
        "질문": "SQA(Software Quality Assurance)의 주요 활동은 무엇인가요?",
        "답변": "프로세스 정의 및 개선, 표준 준수 확인, 품질 메트릭 수집 및 분석, 리뷰 및 감사, 교육 및 훈련, 결함 예방 활동을 수행합니다."
    },
    {
        "질문": "소프트웨어 품질 속성에는 어떤 것들이 있나요?",
        "답변": "기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 등이 있으며, ISO 25010 품질 모델이 표준으로 사용됩니다."
    },
    {
        "질문": "코드 리뷰의 목적과 효과적인 방법은 무엇인가요?",
        "답변": "코드 품질 향상, 결함 조기 발견, 지식 공유가 목적입니다. 체크리스트 사용, 건설적 피드백, 적절한 크기, 자동화 도구 활용이 효과적입니다."
    },
    {
        "질문": "정적 분석과 동적 분석의 차이는 무엇인가요?",
        "답변": "정적 분석은 코드 실행 없이 소스코드를 분석하며(린터, 코드 리뷰), 동적 분석은 프로그램 실행 중 동작을 분석합니다(테스팅, 프로파일링)."
    },
    {
        "질문": "결함 추적 시스템의 주요 기능은 무엇인가요?",
        "답변": "결함 등록 및 관리, 상태 추적, 우선순위 설정, 할당 및 알림, 이력 관리, 통계 및 리포팅, 워크플로우 자동화 기능이 있습니다."
    },
    {
        "질문": "품질 게이트(Quality Gate)란 무엇인가요?",
        "답변": "프로젝트 단계별로 설정된 품질 기준으로, 다음 단계로 진행하기 전 반드시 충족해야 하는 조건입니다. 코드 커버리지, 결함 수 등을 기준으로 합니다."
    },
    {
        "질문": "Shift-Left 테스팅 접근법에 대해 설명해주세요.",
        "답변": "개발 라이프사이클의 초기 단계부터 테스팅을 시작하는 접근법으로, 결함을 조기에 발견하여 수정 비용을 줄이고 품질을 향상시킵니다."
    },
    {
        "질문": "테스트 주도 개발(TDD)의 장점과 프로세스는 무엇인가요?",
        "답변": "Red-Green-Refactor 사이클로 테스트 작성 → 코드 작성 → 리팩토링 순으로 진행합니다. 장점은 높은 코드 품질, 설계 개선, 회귀 방지입니다."
    },
    {
        "질문": "품질 메트릭 수집과 분석의 중요성은 무엇인가요?",
        "답변": "결함 밀도, 테스트 커버리지, 코드 복잡도 등을 측정하여 품질 추세를 파악하고, 데이터 기반 의사결정과 프로세스 개선을 가능하게 합니다."
    },
    {
        "질문": "CI/CD 파이프라인에서 품질 검증을 통합하는 방법은?",
        "답변": "자동화된 빌드, 단위 테스트, 통합 테스트, 정적 분석, 보안 스캔, 성능 테스트를 파이프라인에 포함시켜 코드 커밋마다 자동으로 품질을 검증합니다."
    },
    {
        "질문": "위험 기반 테스팅(Risk-Based Testing)이란 무엇인가요?",
        "답변": "비즈니스 영향도와 발생 가능성을 기준으로 위험을 평가하고, 고위험 영역에 테스팅 리소스를 집중 배분하는 전략적 접근법입니다."
    },
    {
        "질문": "시간 복잡도 VS 공간 복잡도에 대해 설명해주시겠습니까?",
        "답변": "시간 복잡도 : 알고리즘을 수행하는데 연산이 몇번 이루어지는지 공간 복잡도 : 알고리즘이 필요로하는 자원의 양"
    },
    {
        "질문": "시간 복잡도는 실제 수행 시간과 어떤 관계가 있는가?",
        "답변": "실제 수행 시간에 미치는 요소는 아주 많다. CPU의 클록 속도, 1클록에 수행할 수 있는 명령어 수, 프로그램의 메모리 접근 패턴, 운영체제와 컴파일러 버전 등.. 시간 복잡도는 반복문이 반복되는 횟수로 판단한다."
    },
    {
        "질문": "최악의 복잡도는 나쁘지만 실제로는 자주 사용되는 알고리즘을 나열하시오에 대해 설명해주시겠습니까?",
        "답변": "Quick Sort Hash"
    },
    {
        "질문": "빅오 표기법에 대해서 설명해주세요에 대해 설명해주시겠습니까?",
        "답변": "알고리즘의 효율성을 표기해주는 기법 빅오(Big-O) : 최악의 경우 빅오메가(big-Ω) : 최선의 경우 빅세타(big-Θ) : 평균"
    },
    {
        "질문": "Call by value, call by reference의 차이점을 설명하시오.",
        "답변": "Call by Value는 함수를 호출할때 값을 넘겨주고, Call by Reference는 변수의 레퍼런스를 전달합니다. Call by value는 함수 내에서 값이 변경되어도 원본 값은 변경되지 않지만, Call by Reference는 원본 값도 변경된다는 특징이 있습니다."
    },
    {
        "질문": "DFS & BFS에 대해 설명해주시겠습니까?",
        "답변": "DFS 다음 브랜치로 넘어가기 전에 해당 브랜치를 모두 탐색 스택/재귀함수 모든 경로를 방문해야할 경우 시간 복잡도 : 인접행렬 O(V^2), 인접리스트 O(V+E) BFS 인접한 노드부터 먼저 탐색 큐 최소 비용 구하기 시간 복잡도 : 인접행렬 O(V^2), 인접리스트 O(V+E)"
    },
    {
        "질문": "크루스칼 알고리즘과 프림 알고리즘에 대해서 설명해 주세요.",
        "답변": "크루스칼 알고리즘 간선 위주의 알고리즘 정점 개수에 비해 간선이 적은 경우 사용 시간 복잡도 : O(E logE) 1. 간선 오름차순 연결 2. 가중치 가장 작은거 선택 3. 사이클이면 무시하고 지나침 4. 2~3 반복 프림 알고리즘 정점 위주의 알고리즘 간선 개수에 비해 정점 개수가 적은 경우 사용 시간 복잡도 : O(E logV) 1. 정점 선택 2. 정점에서 연결된 간선 중 가장 가중치 작은거 선택 3. 반대편이 이미 추가된 정점이면 무시 4. 2~3반복"
    },
    {
        "질문": "다익스트라 알고리즘에 대해서 설명해 주세요.",
        "답변": "그래프의 최단거리를 찾기 위한 알고리즘 현재까지의 최단거리를 계속 갱신"
    },
    {
        "질문": "LinkedList vs ArrayList의 차이점에 대해 설명해주시겠습니까?",
        "답변": "ArrayList 데이터들이 순서대로 늘어선 배열의 형식 Random access 가능하므로 검색 빠름 삽입/삭제 느림 LinkedList 자료의 주소값으로 연결된 형식 검색 느림 삽입/삭제 빠름"
    },
    {
        "질문": "인접행렬과 인접리스트에 대해 설명해주시겠습니까?",
        "답변": "인접행렬 이차원 배열로 표현 O(V^2) 두 정점 연결되어있는지 여부 → O(1) 모든 노드 방문시 O(V) 간선이 적다면 인접리스트 사용 인접리스트 리스트로 표현 O(V+E) 탐색 시 간선 개수만큼만 방문 두 정점 연결되어있는지 확인 → 정점에 연결된 노드 다 방문 O(V)"
    },
    {
        "질문": "정렬을 하는 이유는 무엇인가요?",
        "답변": "데이터를 탐색하기 위해 만약 정렬이 되어있다면 이진탐색을 할 수 있음"
    },
    {
        "질문": "선택 정렬(Selection Sort)에 대해 설명해주시겠습니까?",
        "답변": "앞에서부터 차근차근 비교하며 정렬하는 방법 불안정 정렬, 제자리 정렬 시간복잡도 O(N^2)"
    },
    {
        "질문": "삽입 정렬(Insertion Sort)에 대해 설명해주시겠습니까?",
        "답변": "원소가 삽입될 자리를 찾아나가는 정렬 방식 안정 정렬, 제자리 정렬 최선의 경우 O(N), 평균/최악의 경우 O(N^2)"
    },
    {
        "질문": "거품 정렬(Bubble Sort)에 대해 설명해주시겠습니까?",
        "답변": "인접한 두 원소를 비교하며 정렬하는 방식 시간복잡도 O(N^2) 안정정렬, 제자리정렬"
    },
    {
        "질문": "병합 정렬(Merge Sort)에 대해 설명해주시겠습니까?",
        "답변": "분할정복을 이용한 방식 데이터를 분할하여 분할된 여러개의 부분집합을 하나의 정렬된 집합으로 병합하여 진행 안정정렬 시간 복잡도 분할 : n개 원소를 두개로 분할 → O(logN) 병합 : 최대 n번의 비교연산 → O(N) 총 시간복잡도 = O(NlogN) 공간 복잡도 : n개에 데이터에 대해 정렬된 데이터를 저장할 추가적인 공간 필요 gyoogle/tech-interview-for-developer 머지 소트(Merge Sort) 합병 정렬이라고도 부르며, 분할 정복 방법을 통해 구현 큰 문제를 작은 문제 단위로 쪼개면서 해결해나가는 방식 빠른 정렬로 분류되며, 퀵소트와 함께 많이 언급되는 정렬 방식이다. https://github.com/gyoogle/tech-interview-for-developer/blob/master/Algorithm/MergeSort.md"
    },
    {
        "질문": "이분 탐색(Binary Search)에 대해 설명해주시겠습니까?",
        "답변": "탐색 범위를 두 부분으로 나누며 탐색함 전체 탐색 O(N) 이분 탐색 O(logN)"
    },
    {
        "질문": "언제 불안정정렬 쓰면 안될까?",
        "답변": "기존의 정렬은 유지해야할때 A,B 쌍인데 B는 이미 정렬상태로 입력됨. 안정정렬쓰면 좋지만 불안정정렬쓰면 기존의 정렬 깨짐"
    },
    {
        "질문": "분할정복에 대해 설명하고 그 예시를 드시오에 대해 설명해주시겠습니까?",
        "답변": "큰 문제를 작은 문제로 나눠서 작은 문제를 해결해 합치면서 해를 구하는 것 Merge Sort / Quick Sort 이분 탐색"
    },
    {
        "질문": "Dynamic Programming가 무엇이고 왜 어떻게 사용하는가?",
        "답변": "복잡한 문제를 간단한 여러개로 나누어 푸는 것 한 가지 문제에 대해 한 번만 품 같은 문제는 항상 정답이 같다"
    },
    {
        "질문": "Memoization 에 대해 설명해주시겠습니까?",
        "답변": "한 번 계산한 것은 저장해두고 재활용함"
    },
    {
        "질문": "안드로이드의 4대 컴포넌트에 대해 설명해주시겠습니까?",
        "답변": "액티비티 : 화면을 관리하고 다양한 이벤트를 처리함 서비스 : 화면에서 보이진 않지만 백그라운드 작업 수행 콘텐츠 프로바이더 : 앱 간의 데이터를 공유하기 위한 인터페이스 제공 브로드캐스트 리시버 : 안드로이드에서 발생하는 브로드캐스트 메시지를 처리함"
    },
    {
        "질문": "안드로이드의 실행환경에 대해 설명해주시겠습니까?",
        "답변": "안드로이드는 크게 4가지로 구성되어있습니다. 리눅스 커널, 라이브러리, 어플리케이션 프레임워크, 어플리케이션 입니다. 리눅스 커널 은 OS로 스마트폰의 메모리나 프로세스 등을 관리합니다. 라이브러리 는 안드로이드에 있는 다양한 기능을 라이브러리를 제공하며 안드로이드 앱을 구동해주는 dalvik 가상머신을 포함합니다. 어플리케이션 프레임워크 는 사용자의 이벤트에 따라 출력을 담당하는 환경을 제공합니다. 생명주기도 여기서 관리. 어플리케이션 은 실제로 동작하는 앱을 말합니다."
    },
    {
        "질문": "안드로이드는 다른 플랫폼에 비해 어떠한 장점이 있는가?",
        "답변": "오픈소스이므로 안정성과 버그 수정이 빠르다 자바를 주 언어로 사용하여 자바 개발자들이 쉽게 개발할 수 있음 리눅스 커널을 OS로 사용하여 하드웨어에 대한 드라이버 소스가 풍부함"
    },
    {
        "질문": "Activity와 Fragment의 차이는?",
        "답변": "Activity : 사용자가 원하는 대로 Activity를 변경할 수 있고, Activity가 변하면 View도 바뀐다 Fragment : 관심사 분리를 통해 의존성을 분리하고 독립성을 키움 액티비티 스택에 액티비티를 쌓아두는 것보다 프래그먼트 백스택에서 프래그먼트를 관리하는 것이 메모리 관리면에서도 효율적"
    },
    {
        "질문": "Activity의 Lifecycle에 대해 설명해주시겠습니까?",
        "답변": "액티비티는 크게 3가지 상태가 존재합니다. 먼저 running 실행 상태 는 액티비티 스택의 최상위에 있으며 포커스를 가지고 있어 사용자에게 보이는 상태입니다. pasued 일시 중지 상태 는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태입니다. stopped 중지 상태 는 다른 액티비티에 의해 완전히 가려져 보이지 않는 상태를 말합니다. 액티비티가 처음 생성되면 onCreate가 호출되고, 그 다음으로 화면에 보여지기 직전에 onStart가 호출됩니다. 사용자가 상호작용하기 직전에 onResume이 호출되면 액티비티는 running 실행 상태가 됩니다. 이후 포커스를 잃는다면 onPaused가 호출되고 paused 일시 중지 상태가 됩니다. 만약 다시 포커스를 갖게 되면 onResume이 호출되고 화면이 가려져 보이지 않는 상태가 된다면 onStop이 호출되어 stopped 중지 상태가 됩니다. 정지 상태에서 화면이 다시 보이기 직전에 onRestart와 onStart가 차례로 호출됩니다. 마지막으로 finish 메소드가 호출되어 액티비티가 소멸하기 직전에 onDestroy가 호출됩니다."
    },
    {
        "질문": "ListView와 RecyclerView의 차이는?",
        "답변": "RecyclerView layout manager viewholder 패턴 강제 구현 → View의 재사용 가능 oncreateviewholder새롭게 생성될때만 호출 itemdecoration과 itemanimation 있음 linear/grid/staggeredgrid 레이아웃매니저 있음 ListView findviewbyid와 inflate를 연속적으로 발생시키면 메모리와 성능에 악영향 미칠수있음 수직 스크롤만 가능"
    },
    {
        "질문": "View가 그려지는 과정에 대해 설명해주시겠습니까?",
        "답변": "액티비티가 포커스를 얻으면 자신의 레이아웃을 그리도록 한다 액티비티에 레이아웃의 계층구조 중 루트 노드를 제공해야함 레이아웃의 루트노드에서 시작해 레이아웃 트리를 따라 이동 부모 뷰는 자식 뷰 이전에 그려짐 자식 뷰는 전위순회 방식으로 그려짐 measure, layout 단계가 있음"
    },
    {
        "질문": "Intent와 Intent filter란 무엇인가?",
        "답변": "Intent 란 안드로이드 컴포넌트간에 통신을 하기 위한 메세지 객체이다. 명시적 인텐트(Explicit Intent) : 시작할 컴포넌트 이름 지정 암시적 인텐트(Implicit Intent) : 컴포넌트를 제외한 나머지를 지정, 사용자가 선택 암시적 인텐트를 통해 사용자가 어떤 앱을 사용할지 선택하도록 할 때 Intent Filter 가 필요하다. 암시적 인텐트"
    },
    {
        "질문": "ANR이란 무엇인가?",
        "답변": "앱의 UI 스레드가 너무 오랫동안 차단되면 ANR 오류가 트리거됨 앱이 입력 이벤트나 BroadcastReceiver에 5초 이내로 응답하지 않음 포그라운드에 Activity 없는데 BroadcastReceiver가 실행을 완료하지 못함"
    },
    {
        "질문": "인플레이션이란 무엇인가?",
        "답변": "자바 소스코드에서 xml의 구성요소들을 사용할 수 있게 객체로 만들어주는것 메모리상에 실제로 객체화되어 앱에 보여지는 것"
    },
    {
        "질문": "Context란 무엇인가?",
        "답변": "Context란 안드로이드의 컴포넌트들이 동작하기 위해 필요한 정보를 담고 있는 것이다. Context를 통해 시스템 레벨의 정보를 얻을 수 있는 메소드를 쓸 수 있다. 애플리케이션 별로 리소스 및 클래스에 대한 접근은 물론 Activity의 실행, 브로드 캐스팅 및 Intent수신과 같은 애플리케이션 레벨에 대한 호출을 허용한다."
    },
    {
        "질문": "안드로이드 매니페스트 파일이란 무엇인가?",
        "답변": "매니페스트는 앱의 이름, 버전, 구성요소, 권한 등 앱의 실행에 있어 필요한 각종 정보들이 저장되어있는 파일이다. 안드로이드 프로젝트의 최상위에 위치하고 있다."
    },
    {
        "질문": "Thread, Looper, Handler에 대해 설명해주시겠습니까?",
        "답변": "Looper와 Handler는 스레드 간 통신을 도와준다. Looper 스레드 당 하나만 가질 수 있다 메시지 큐가 비어있으면 아무것도 하지않고, 메시지가 들어오면 꺼내서 Handler에 전달 Main 스레드는 Looper를 가지지만, 기본적으로는 Looper를 가지지않음 Handler Message나 Runnable 객체를 처리함 Thread, Looper, MessageQueue에 의존적"
    },
    {
        "질문": "디스플레이(display), 윈도우(window), 서피스(surface), 뷰(view), 뷰 그룹(view group), 뷰 컨테이너(view container), 레이아웃(layout)에 대해서 설명하시오.",
        "답변": "디스플레이 : 안드로이드 단말기가 가지는 하드웨어 화면 윈도우 : 앱이 그림을 그릴수있는 영역 서피스 : 윈도우에 그림을 그릴 때 그림이 저장되는 메모리 버퍼 뷰 : 사용자 인터페이스를 구성하는 최상위 클래스 뷰 그룹 : 여러개의 뷰를 포함하고 있는 뷰를 의미함 뷰 컨테이너 : 다른 뷰를 포함하고 있는 뷰 레이아웃 : 뷰를 윈도우에 어떻게 배치할지 정의하는 관리자"
    },
    {
        "질문": "노티피케이션(notification)은 무엇인가?",
        "답변": "안드로이드가 앱의 UI 외부에 표시하는 메시지"
    },
    {
        "질문": "태스크(task)란 무엇인가?",
        "답변": "Task란 사용자가 특정 작업을 할 때 상호작용하는 Activity의 모음이다."
    },
    {
        "질문": "안드로이드의 메모리 관리 방식에 대해서 설명하시오.",
        "답변": "안드로이드 런타임(ART)와 Dalvik 가상 머신은 페이징과 메모리 매핑을 통해 메모리를 관리함"
    },
    {
        "질문": "Annotation이란?",
        "답변": "일종의 메타데이터 컴파일/런타임 과정에서 코드를 어떻게 처리할 지 알려주는 정보 컴파일러에게 코드 문법 에러를 체크하도록 정보 제공 런타임시 특정 기능 실행하도록 정보 제공 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공"
    },
    {
        "질문": "ViewPager란?",
        "답변": "데이터를 페이지 단위로 표시하고, swipe를 통해 페이지를 전환할 수 있도록 만들어주는 컨테이너"
    },
    {
        "질문": "Dependency Injection이란?",
        "답변": "의존성 주입이란 외부에서 의존 객체를 주입해줘서 결합도를 줄여주는 것을 말합니다. 생성자에서 주입하는 방식과 setter를 사용하는 방법이 있습니다. 장점은 (1) 종속성이 감소해 변경에 대한 여파가 줄어들고, (2)재사용성이 증가하고, (3) 테스트가 용이합니다."
    },
    {
        "질문": "Koin과 Dagger의 차이점은?",
        "답변": "Koin 런타임과정에 DI 주입 컴파일이 빠름 런타임 에러 가능 Module에서 선언한 DI를 캐시에 저장하고 by inject로 캐시를 조회해서 객체를 가져옴 Dagger Annotation을 통해 컴파일과정에 DI 주입 컴파일은 느리지만 런타임에서 에러 발생하지 않음 컴파일 시 오버헤드 발생"
    },
    {
        "질문": "SharedPreferences란?",
        "답변": "키-값 쌍이 포함된 파일을 가리킴 데이터를 파일로 저장하므로 앱을 삭제하면 데이터도 삭제됨"
    },
    {
        "질문": "DiffUtil이란?",
        "답변": "두 목록 간의 차이점을 찾고 업데이트되어야 할 목록을 반환함 추가 및 제거 작업할 아이템을 찾기위해 O(n) 소요"
    },
    {
        "질문": "직렬화와 역직렬화란?",
        "답변": "직렬화 객체를 연속적인 데이터로 변형해 전송 가능한 형태로 만드는것 JVM 메모리에 상주되어있는 객체를 바이트 형태로 변환 역직렬화 직렬화된 파일을 다시 객체의 형태로 만드는것 직렬화된 바이트 형태의 데이터를 객체로 변환해 JVM으로 상주시킴 직렬화해야하는 이유 디스크에 저장하거나 통신에는 value type만 가능하고 reference타입은 불가능 PC마다 사용하고 있는 메모리 주소는 다르다."
    },
    {
        "질문": "Immutable이란?",
        "답변": "값을 변경할 수 없는 것"
    },
    {
        "질문": "Image Loading 라이브러리에는 어떤 것이 있는가?",
        "답변": "Glide 화질이 더 안좋음 메모리 덜 씀 Picasso 화질 좋음 메모리 더 씀"
    },
    {
        "질문": "Android Ktx이란?",
        "답변": "코틀린 개발용 확장 라이브러리 확장함수, 람다, 이름이 지정된 매개변수, 코루틴 등 지원"
    },
    {
        "질문": "데이터바인딩이란?",
        "답변": "데이터바인딩 데이터를 결합시켜 동기화하는 방식 안드로이드 데이터바인딩 라이브러리 UI 컴포넌트와 데이터를 programmatic하게 연결하지 않고, 선언형으로 결합하도록 도와줌"
    },
    {
        "질문": "GSON이란?",
        "답변": "JSON과 JAVA 사이의 직렬화와 역직렬화를 도와주는 라이브러리"
    },
    {
        "질문": "Retrofit과 Okhttp란?",
        "답변": "Retrofit Type-safe한 HttpClient 라이브러리 Type-safe : 네트워크로부터 전달된 데이터를 우리 프로그램에서 필요한 형태의 객체로 받을 수 있음 보통 Http 요청을 위해서는 연결, 캐싱, 재시도, 스레딩, 응답 분석, 오류 처리 등을 해야하는데, 라이브러리는 이것들을 알아서 해줌 OkHttp REST API와 HTTP통신을 간편하게 구현할 수 있도록 도와주는 라이브러리"
    },
    {
        "질문": "Volley와 Retrofit의 차이는?",
        "답변": "Volley 용량이 작고 빠른 실행 속도 동시 네트워크 연결 요청 우선순위 지원 JSON Object나 Array 반환 Retrofit 속도가 빠르다"
    },
    {
        "질문": "재귀를 이용한 피보나치 수열에 대해 설명해주시겠습니까?",
        "답변": "시간복잡도 : O(2^n) int fibo(int n){ if(n<2) return n; return fibo(n-1) + fibo(n-2); }"
    },
    {
        "질문": "메모이제이션을 이용한 피보나치 수열에 대해 설명해주시겠습니까?",
        "답변": "시간복잡도 : O(N) int memo[MAX]={0,}; int fibo(int n){ if(memo[n]!=0) return memo[n]; if(n<2) return n; return memo[n] = fibo(n-1) + fibo(n-2); }"
    },
    {
        "질문": "동적계획법을 이용한 피보나치 수열에 대해 설명해주시겠습니까?",
        "답변": "시간복잡도 : O(N) int dp[MAX] = {0,}; dp[1] = 1; dp[2] = 2; for(int i=3;i<=N;i++){ dp[i] = dp[i-1] + dp[i-2]; }"
    },
    {
        "질문": "재귀를 이용한 팩토리얼에 대해 설명해주시겠습니까?",
        "답변": "int fact(int n){ if(n==1) return 1; return n*fact(n-1); }"
    },
    {
        "질문": "퀵 정렬 구현에 대해 설명해주시겠습니까?",
        "답변": "void quickSort(int* arr, int left, int right) if(left>=right) return; int pivot = left; int i = left+ 1; int j = right; while (i <= j) { // 엇갈릴 때까지 반복 while (i <= right && (array[i] <= array[pivot])) i++; while (j > left && (array[j] >= array[pivot])) j--; if (i > j) swap(array[j], array[pivot]); else swap(array[i], array[j]); } quickSort(arr, left, lt-1); quickSort(arr, lt+1, right); }"
    },
    {
        "질문": "합병 정렬 구현에 대해 설명해주시겠습니까?",
        "답변": "void mergeSort(int* arr, int left, int right){ if(left>=right) return; int mid = (left + right) / 2; mergeSort(left, mid); mergeSort(mid+1, right); int p1 = left; int p2 = mid+1; int p3 = left; while(p1 <= mid && p2 <= right) { if(arr[p1] < arr[p2]) temp[p3++] = arr[p1++]; else temp[p3++] = arr[p2++]; } while(p1<= mid) temp[p3++] = arr[p1++]; while(p2<= right) temp[p3++] = arr[p2++]; for(int i=left; i<=right;i++) arr[i] = temp[i]; }"
    },
    {
        "질문": "Constructor와 Destructor에 대해 설명해주시겠습니까?",
        "답변": "**생성자**: 객체가 생성될 때 실행되는 함수, 객체의 초기화가 목적 **소멸자**: 객체의 사용이 끝나고 메모리에 반환될때 실행되는 함수"
    },
    {
        "질문": "C++에서 Default Constructor는 무엇을 의미하는가?",
        "답변": "클래스에는 생성자가 반드시 있어야 한다. 사용자가 생성자를 따로 생성하지 않으면 컴파일러가 기본 생성자를 자동으로 생성해준다."
    },
    {
        "질문": "C++에서Virtual은 왜 존재하는가?",
        "답변": "오버라이딩을 기대하는 함수에 쓴다. virtual을 쓰면 런타임에 함수가 매핑이 되는 동적바인딩이 수행된다."
    },
    {
        "질문": "malloc과new의 차이는 무엇인가?",
        "답변": "malloc은 함수이다. 함수 내에서 메모리를 할당한다. new는 연산자이다. 생성자를 호출하면서 메모리를 할당한다."
    },
    {
        "질문": "struct와 class의 차이는 무엇인가?",
        "답변": "둘 다 데이터를 담는 그릇이다. struct : 기본 접근 제어자 public class : 기본 접근 제어자 private"
    },
    {
        "질문": "키 종류는 무엇인가요?",
        "답변": "후보키 : 유일성과 최소성을 만족한 키 유일성 : 해당 키로 하나의 튜플을 식별할수있음 최소성 : 꼭 필요한 속성으로만 이루어짐 기본키 : 후보키들 중 하나, Null 가질 수 없음, 동일한 값을 가질수없음 대체키/보조키 : 기본키를 제외한 후보키 외래키 : 다른 릴레이션의 속성, 참조 관계를 표현하는 데에 쓰임 슈퍼키 : 유일성은 만족하지만 최소성은 만족하지 못하는 키"
    },
    {
        "질문": "JOIN에 대해서 설명해 주세요.",
        "답변": "두 가지 이상의 릴레이션을 연결해서 데이터를 검색하는 기법 RDBMS에서는 릴레이션끼리 관계를 가지고 있는데, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다."
    },
    {
        "질문": "내부 조인, 외부 조인, 셀프 조인에 대해 설명해주시겠습니까?",
        "답변": "내부 조인(Inner Join) : 가장 기본적인 조인 동등 조인(EQUI Join) : 동등 비교(=) 사용 자연 조인(Natural Join) : 동일한 컬럼명을 가진 테이블에서 모든 컬럼 비교 3. 교차 조인(Cross Join) : 곱집합 반환, 모든 경우의 수(M*N) 외부 조인(Outer Join) : 특정 테이블의 데이터가 모두 필요한 경우 Left Outer Join : 좌측 테이블의 모든 결과값 포함 Right Outer Join : 우측 테이블의 모든 결과값 포함 셀프 조인 (Self Join) : 자기 자신과 자기 자신 결합"
    },
    {
        "질문": "SQL Injection이란 무엇인가요?",
        "답변": "해커에 의해 조작된 쿼리문에 DB에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법"
    },
    {
        "질문": "파티셔닝과 샤딩에 대해서 설명해 주세요.",
        "답변": "파티셔닝 데이터를 여러 DB에 분산시키는 것 X테이블의 일부 데이터는 A에, Y테이블의 일부 데이터는 B에 수평 단편화/수평 파티셔닝/샤딩 데이터를 수평으로 쪼갠다 수직 단편화/수직 파티셔닝 수직으로 칼럼을 쪼갬 칼럼을 나눠서 새로운 테이블로 갖고있는 것 특정 컬럼이 빈번하게 참조될때, 여러 데이터가 캐시에 올라갈수있음"
    },
    {
        "질문": "ORM이란 무엇인가요?",
        "답변": "ORM (Object - Relation Mapping) 객체-관계 매핑 객체지향적인 코드로 비즈니스 로직에 집중 가능 객체와 RDBMS간의 매핑을 하는 것 재사용 및 유지보수 용이 DBMS에 대한 종속성 감소"
    },
    {
        "질문": "NoSQL이란 무엇인가요?",
        "답변": "NoSQL RDBMS와 달리 다른 형태의 데이터 저장 데이터 간의 관계 저장하지않음 고정되지않은 테이블 스키마 장점 유연함, 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할수있음 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨 단점 중복을 계속 업데이트해야 함 데이터 구조 결정을 미루게 될 수 있음 수정 시 중복된 모든 컬렉션에서 수행해야함"
    },
    {
        "질문": "스키마란 무엇인가요?",
        "답변": "DB의 구조와 제약조건에 관해 명세를 기술한 것"
    },
    {
        "질문": "View란 무엇인가요?",
        "답변": "가상테이블 보안관리, 편의, 수행속도 향상 저장장치 내에 물리적으로 존재하지는 않음 필요한 데이터만 뷰로 정의할수있음 독립적 인덱스 불가능, CRUD에 제약이 있음"
    },
    {
        "질문": "이상 현상에 대해서 설명해 주세요.",
        "답변": "데이터의 중복으로 인한 부작용을 말합니다 삽입 이상 : 데이터를 삽입하는 데 필요없는 속성도 함께 추가해야함 갱신 이상 : 데이터를 갱신한 이후 일관성이 위반됨 삭제 이상 : 데이터를 삭제하는 데 의도하지 않은 것이 함께 삭제됨, 정보 손실이 일어남"
    },
    {
        "질문": "정규화에 대해서 설명해 주세요.",
        "답변": "정규화 란 RDBMS에서 중복을 최소화하기 위해 데이터를 분해하는 작업을 말합니다. 정규화를 함으로써 이상현상을 방지할 수 있다는 장점이 있고, 릴레이션 간의 연산이 많아질 수 있다는 단점이 있습니다."
    },
    {
        "질문": "반정규화란?",
        "답변": "반정규화 는 성능 향상을 위해 중복,통합을 하는 기법이다. 조인으로 인한 성능 저하가 예상되는 경우 반정규화를 실행한다. 반정규화를 과도하게 적용하면 무결성이 깨질수있다."
    },
    {
        "질문": "정규화의 종류에 대해서 말해보세요.",
        "답변": "제 1 정규형 : 도메인이 원 자값만을 포함함 제 2 정규형 : 완 전 함수적 종속 제 3 정규형 : 기본키에 대해 이 행적 종속 제거 BCNF 정규형 : 모든 결정키가 후 보키"
    },
    {
        "질문": "함수적 종속성이란 무엇인가요?",
        "답변": "X → Y : 릴레이션 R에서 X값을 알면 Y를 알 수 있고, X 값에 의해 Y값이 달라질 때 , Y는 X에 함수적 종속이다."
    },
    {
        "질문": "인덱스란 무엇인가요? 어떻게 동작 하나요?",
        "답변": "인덱스 RDBMS에서 검색 연산의 속도를 높이기 위한 방법 항상 정렬된 상태를 유지하므로 탐색이 빠르다 데이터 삽입/삭제/수정 시에는 추가적인 작업이 필요하므로 실행 속도가 느려진다. 저장 성능을 희생하고 데이터 읽기 속도를 높이는 기능 인덱스 자료구조 B+- Tree : 일반적으로 사용됨 Hash : 해시 값을 계산해 검색하므로 빠르나 부분 검색을 할 수 없음 인덱스를 사용하면 좋은 경우 where 절에서 자주 사용되는 Column 외래키에 사용되는 Column Join에 자주 사용되는 Column 인덱스를 피해야 하는 경우 데이터의 중복도가 높은 Column 삽입, 삭제, 수정 연산이 자주 일어나는 Column"
    },
    {
        "질문": "인덱스의 알고리즘에는 어떤 것들이 있나요?",
        "답변": "B Tree 인덱스 알고리즘 : 칼럼의 값을 변형하지 않고 원래의 값으로 인덱싱, 등호 뿐만 아니라 부등호 연산에도 적용 가능 Hash 인덱스 알고리즘 : 해시값을 이용해 인덱싱"
    },
    {
        "질문": "클러스터드 인덱스와 비클러스터드 인덱스란 무엇인가?",
        "답변": "클러스터드 인덱스 테이블당 하나만 생성 가능 인덱스로 지정한 열에 맞춰 자동 정렬 비클러스터드 인덱스 테이블당 여러개 생성 가능"
    },
    {
        "질문": "트랜잭션이란 무엇인가요? 4가지 원칙을 포함해서 설명해 주세요.",
        "답변": "트랜잭션 : 데이터베이스의 상태를 변경시키는 작업의 단위 4가지 특징 ACID Atomicity(원자성) : 트랜잭션의 연산은 모두 반영되어야하며, 하나라도 실패하면 모두 취소되어야한다. Consistency(일관성) : 트랜잭션을 성공하면 언제나 일관성있는 데이터베이스 상태로 변화한다. Isolation(독립성, 격리성) : 둘 이상의 트랜잭션이 동시에 수행되는 경우 다른 트랜잭션의 연산에 끼어들수없다. Durability(지속성) : 완료된 트랜잭션은 영구적으로 반영되어야한다."
    },
    {
        "질문": "트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해보세요.",
        "답변": "트랜잭션 격리 수준(Isolation level) : 트랜잭션에서 일관성 없는 데이터를 허용하는 수준 레벨 0 - Read Uncommitted 트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함 레벨 1 - Read Committed Commit이 이루어진 트랜잭션만 조회 가능 레벨 2 - Repeatable Read 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능 레벨 3 - Serializable 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능"
    },
    {
        "질문": "Commit과 Rollback이란 무엇인가요?",
        "답변": "Commit 모든 작업을 정상적으로 처리하겠다고 확정하는 명령 실제 DB에 저장 Commit 수행 후 하나의 트랜잭션을 종료하게 됨 Rollback 작업 중 문제가 발생하면 변경사항을 취소하고 트랜잭션을 종료함 이전 commit까지만 복구함 장점 데이터 무결성 보장"
    },
    {
        "질문": "배열과 링크드 리스트의 차이점에 대해서 설명해 주세요.",
        "답변": "배열은 메모리에 할당될 때 연속적인 데이터 공간에 할당이 됩니다. 데이터에 접근할 때 random access가 가능하므로 빠르지만, 삽입 삭제 시에나 배열의 크기를 유동적으로 변하기 어렵습니다. 링크드 리스트는 메모리에 할당될 때 흩어져서 저장됩니다. 처음에 크기를 지정해주지 않아도되며 삽입 삭제가 빠르지만 검색시 순차접근을 통해서 접근해야하므로 느립니다."
    },
    {
        "질문": "스택과 큐에 대해서 설명해 주세요.",
        "답변": "스택 가장 마지막으로 들어온 자료가 먼저 나가는 후입선출(LIFO) ex) 재귀 알고리즘, 함수의 스택프레임 저장, 뒤로가기 큐 먼저 들어온 자료가 먼저 나가는 선입선출(FIFO) 데이터가 들어간 순서대로 처리되어야 할 때 사용 ex) BFS, 프로세스 관리, CPU 스케줄링"
    },
    {
        "질문": "우선순위 큐에 대해서 설명해 주세요.",
        "답변": "우선순위를 가지고 있는 큐"
    },
    {
        "질문": "해시테이블에 대해서 설명해 주세요.",
        "답변": "key-value를 함께 저장하는 자료구조 key를 통해 value값을 얻어냄 key, hash function, hash, value로 이루어짐 서로 다른 키의 해시값이 동일하게 나오는 경우 해시 충돌이 일어난다 장점 적은 리소스로 많은 데이터를 효율적으로 관리 가능 배열 인덱스를 사용하므로 검색, 삽입, 삭제가 빠르다 단점 충돌 발생 가능성 공간 복잡도 증가 들어온 순서 무시 해시 알고리즘 Chaining 개방 주소법 - 선형 조사, 2차 조사, 이중 해싱"
    },
    {
        "질문": "그래프와 트리의 차이점에 대해서 설명해 주세요.",
        "답변": "그래프 정점과 간선을 모아놓은 자료구조 연결되어있는 객체 간의 관계 표현 가능 무방향/방향 가능 self-loop, cycle 가능 EX) 지도, 지하철 노선도, 회로 트리 계층 구조를 가지는 그래프의 한 형태 하나의 루트 노드를 가짐 loop, cycle 불가능"
    },
    {
        "질문": "최소 신장 트리에 대해서 설명해 주세요.",
        "답변": "모든 노드를 잇는 신장 트리에서 간선의 가중치 합이 최솟값인 트리 EX) 도로 건설, 전기 회로, 통신, 배관"
    },
    {
        "질문": "힙 자료구조에 대해 설명해 주세요.",
        "답변": "완전 이진 트리의 일종 우선순위큐에 사용 최댓값이나 최솟값을 빠르게 찾을 수 있음 중복된 값 허용"
    },
    {
        "질문": "힙의 삽입과 삭제는 어떻게 이루어지나요?",
        "답변": "삽입 마지막에 노드 추가 부모와 비교 → 부모보다 크면 swap 2 반복 삭제 노드 삭제 마지막 노드를 부모로 가져옴 부모가 자식보다 작으면 → 자식 중 큰 값과 swap 3 반복"
    },
    {
        "질문": "이진 탐색 트리에 대해 설명해 주세요.",
        "답변": "이진 트리(탐색이 O(logN)) + 연결리스트(삽입,삭제가 O(1)) 왼쪽 자식에는 부모보다 작은 값 오른쪽 자식에는 부모보다 큰 값으로 이루어짐 순회시에는 중위순회를 사용 중복이 없어야함 균등 트리인 경우 O(logN), 편향 트리인 경우 O(N)"
    },
    {
        "질문": "포화(Perfect) 이진트리, 완전(Complete) 이진트리, 정(Full) 이진트리의 차이점에 대해 각각 설명해주세요.",
        "답변": "포화이진트리 : 리프노드를 제외한 모든 노드가 두개의 자식을 가지고 있는 트리 완전이진트리 : 왼쪽부터 차근차근 채워진 이진트리 정이진트리/적정이진트리 : 노드들이 자식을 0개 혹은 2개만 가지고 있는 이진트리"
    },
    {
        "질문": "AVL에 대해 설명해주세요.",
        "답변": "자식들의 좌우 높이차이가 1을 넘지않는 BST 높이 O(logN) 탐색, 삽입, 삭제 O(logN)"
    },
    {
        "질문": "B-Tree와 B+Tree에 대해서 설명해 주세요.",
        "답변": "B-Tree 하나의 노드에 데이터가 여러개 한 노드에 최대 M개의 데이터 저장할수 있으면 M차 B-Tree M이 짝수냐 홀수냐에 따라 알고리즘이 다름 자식 노드가 2개 이상 가능 키 중복 없음 규칙 노드의 데이터 수가 N이면 자식의 수는 N+1이다. 노드의 데이터는 정렬된 상태이다 데이터는 중복될 수 없다. B+Tree 노드에 key만 담아두고, leaf 노드에 key와 data 저장 모든 값을 leaf에 있고, 나머지는 데이터를 위한 방향성을 제공 리프 노드끼리 Linked List로 연결되어있음 하나의 노드에 많은 key를 담을 수 있으므로 트리의 높이는 더 낮아짐(cache hit을 높임) 키 중복 가능 리프 노드에서 선형 탐색"
    },
    {
        "질문": "Substring Problem의 종류와 원리를 설명해주시겠습니까?",
        "답변": "Brute Force KMP Rabin-Karp"
    },
    {
        "질문": "아래처럼 동작하는 flatten함수를 reduce를 활용해서 만들어보세요.",
        "답변": "const arr = [[1, 2], [3, 4], [5, 6]]; const flattenedArray = flatten(arr); console.log(flattenedArray) //[1, 2, 3, 4, 5, 6];"
    },
    {
        "질문": "reset revert의 차이는 무엇인가요?",
        "답변": "reset 특정 커밋을 사용하지 않게 되어 되돌릴때 HEAD가 뒤로 돌아가며 이후의 커밋은 삭제됨 공용 브랜치에서는 사용하지 말기 revert 변경사항을 취소하는 새로운 커밋을 남김 rollback한 이력이 남기때문에 비교적 안전함"
    },
    {
        "질문": "merge rebase squash의 차이는 무엇인가요?",
        "답변": "merge : 변경 이력 전체를 합침 rebase : 커밋이 각각 하나씩 합쳐짐, 하나의 parent squash : 변경 이력을 합치는데 하나의 parent로 만듦"
    },
    {
        "질문": "Java의 Collection에 대해서 설명해 주세요.",
        "답변": "여러 데이터를 담을 수 있는 자료구조 list, set 등이 있음"
    },
    {
        "질문": "Wrapper Class란 무엇인가요?",
        "답변": "java에는 primitive type과 reference type이 있습니다. primitive type의 경우 NULL 값을 담지 못하고, 제네릭 프로그래밍에 쓰지 못한다는 특징이 있는데, 이러한 경우와 같이 데이터를 객체로 표현해야 할 때 쓰이는 것이 Wrapper입니다."
    },
    {
        "질문": "직렬화(Serialization)과 역직렬화(Deserialization)에 대해서 설명해 주세요.",
        "답변": "직렬화 : 데이터를 연속적인 데이터로 변형하는 것 역직렬화 : 직렬화된 데이터를 변환하여 객체의 형태로 표현하는 것"
    },
    {
        "질문": "Java Generic에 대해서 설명해 주세요.",
        "답변": "제네릭이란 어떤 객체의 타입인지에 관계없이 프로그래밍하는 것을 말합니다. 객체를 초기화할때 타입을 지정해주기 때문에 타입캐스팅이 필요없고 컴파일 타임에 타입체크를 해주기때문에 디버깅이 쉽다는 장점이 있습니다. **제네릭** - 다양한 타입의 객체를 사용하는 메소드나 클래스에서 객체를 초기화할 때 타입을 지정해주는 기법 **장점** - 코드 간결 - 컴파일 타임에 오류 체크 - 타입 캐스팅할 필요 없음 - 재사용성 증가 제네릭을 사용하지 않을 경우 EX) 만약 제네릭을 사용하지 않고 Object 클래스를 상속받는 경우 매번 타입캐스팅을 해주어야함. 만약 타입캐스팅이 잘못되면 런타임시 ClassCastException 오류 발생함"
    },
    {
        "질문": "제네릭을 사용하지 않을 경우에 대해 설명해주시겠습니까?",
        "답변": "EX) 만약 제네릭을 사용하지 않고 Object 클래스를 상속받는 경우 매번 타입캐스팅을 해주어야함. 만약 타입캐스팅이 잘못되면 런타임시 ClassCastException 오류 발생함"
    },
    {
        "질문": "equals와 ==의 차이는 무엇인가요?",
        "답변": "기본적인 동작은 똑같은데 , equals는 override할수 있기때문에 사용자가 원하는 논리적인 통일성을 비교할 수 있다. `==` - 참조 비교 : 두 객체가 같은 메모리 공간을 가리키는 지 확인 `equals()` - 내용 비교 : 두 객체의 값 확인"
    },
    {
        "질문": "hashCode란 무엇인가요?",
        "답변": "두 객체가 동일한 객체인지 비교 가능 heap 에 저장된 객체의 메모리 주소 반환"
    },
    {
        "질문": "문자열을 리터럴(string = \"abcd\")로 할당하는 것과 객체(string = new String(\"abcd\"))로 할당하는 방식의 차이가 무엇인가요?",
        "답변": "리터럴 : string constant pool에 생성 new : heap에 생성 == 연산도 다름"
    },
    {
        "질문": "익명함수란?",
        "답변": "리터럴 방식으로 만들어진 이름없는 함수 재사용을 안하기때문에 이름없이 만든다. //리터럴 방식 var a = 10; var name = superman; //익명함수 var funcA = function(name){ alert(name + \"님 환영합니다\"); }"
    },
    {
        "질문": "Lambda란?",
        "답변": "람다란 함수형 프로그래밍을 지원하기 위해 자바8부터 나온 표현식으로, 함수형 인터페이스를 이용하는 방식입니다. 익명함수의 한 형태입니다. 코드가 간결해지고 가독성이 높아진다는 장점이 있는 반면에, 남용시 디버깅이 어려워질 수 있다는 단점이 존재합니다."
    },
    {
        "질문": "정적 바인딩 vs 동적 바인딩에 대해 설명해주시겠습니까?",
        "답변": "바인딩 : 함수를 호출할 때 함수가 위치한 메모리로 연결시켜주는 것 정적 바인딩 : 컴파일 타임에 결정, 컴파일 시간에 정보가 결정되므로 효율 좋음 동적 바인딩 : 런타임에 결정, 런타임에 자유롭게 바뀌므로 적응성 좋음, 타입 체크로 인한 수행 속도 저하"
    },
    {
        "질문": "Callable과 Runnable의 차이는?",
        "답변": "둘다 스레드를 구현하기 위한 인터페이스임 **Callable** - 리턴 타입 존재 - Exception 발생 **Runnable** - 리턴 타입 없음 - Exception 없음"
    },
    {
        "질문": "Thread-safe하게 프로그래밍 하려면?",
        "답변": "- `volatile` : 캐시에 저장하지 않고 메모리에서 접근하겠다 (ex. 하나의 스레드만 RW하고 나머지는 R하는 경우) - `synchronized` 키워드 : Lock기법 - `Atomic` 클래스 : CAS(Compare And Swap)기반, 특정 메모리 위치 값과 주어진 값을 비교해 같으면 새로운 값으로 변경"
    },
    {
        "질문": "HashSetvsTreeSet에 대해 설명해주시겠습니까?",
        "답변": "**HashSet** - 해싱으로 구현 - TreeSet보다 빠름 - 정렬 불가 **TreeSet** - 이진탐색트리 형태로 데이터 저장 - 레드-블랙 트리로 구현됨 - 추가/삭제에는 시간 걸리지만 검색과 정렬 뛰어남 - 저장순서 유지X"
    },
    {
        "질문": "HashMapvsHashTable에 대해 설명해주시겠습니까?",
        "답변": "**HashMap** - 비동기 - 보조해시 사용 **HashTable** - 동기, thread-safe - 멀티스레드가 아니라면 HashMap보다는 성능이 떨어짐 - Null 허용하지 않음"
    },
    {
        "질문": "HashSetvsHashMap에 대해 설명해주시겠습니까?",
        "답변": "**HashSet** - 중복된 객체 비허용 - 객체 저장 - equals() hashCode() 메소드로 중복 여부 체크 - HashMap에 비해 느림 **HashMap** - Map 인터페이스 구현 - key-value 형식 데이터 저장 - HashSet에 비해 빠름"
    },
    {
        "질문": "자바와 코틀린 차이점에 대해 설명해주시겠습니까?",
        "답변": "코틀린 : Null에 안전"
    },
    {
        "질문": "함수형 프로그래밍이란 무엇인가요?",
        "답변": "함수도 객체로 취급 코드 간략, 재사용성 증가 람다식, 고차함수, 순수함수 모듈화 하므로 디버깅, 테스트 용이 생산성 높다"
    },
    {
        "질문": "코틀린 장점는 무엇인가요?",
        "답변": "문법이 간결하다 컴파일 타임에 Null을 체크하므로 Null 안전하다 JVM을 기반으로 하므로 자바에서 제공하는 Collection을 그대로 사용할수있음"
    },
    {
        "질문": "sealed class VS data class에 대해 설명해주시겠습니까?",
        "답변": "sealed class 하위 클래스의 종류를 제한 객체 생성 불가능 하위 클래스는 class, data class, object 가능 when절에서 else문 필요없음 sealed의 하위 클래스들은 객체 여러개 생성 가능 → enum은 인스턴스 하나임 data class 데이터만 담기 위한 클래스 getter/setter 자동 생성"
    },
    {
        "질문": "고차함수 vs 순수함수 vs 일급객체에 대해 설명해주시겠습니까?",
        "답변": "고차함수 함수를 인자로 전달받거나 함수를 반환하는 함수 순수함수 side effect 없음 : 입력이 같으면 출력이 같다 일급객체 함수의 인자로 전달 가능 함수의 반환값에 사용 가능 변수에 담을 수 있음"
    },
    {
        "질문": "obejct vs companion object에 대해 설명해주시겠습니까?",
        "답변": "object 클래스를 정의하면서 객체 생성 상속 가능 companion object 코틀린에는 static 없다 말그대로 동반 객체임 클래스의 private 데이터에 접근 가능"
    },
    {
        "질문": "lateinit VS by lazy에 대해 설명해주시겠습니까?",
        "답변": "lateinit var primitive에 사용 불가능 null을 통한 초기화 불가능 by lazy val 기본 synchronized로 동작"
    },
    {
        "질문": "OSI 7계층에 대해서 설명해주세요.",
        "답변": "나눈 이유 : 통신이 일어나는 과정을 단계별로 알수있고, 문제가 생기면 그 단계만 수정하면 됨 물리 : 데이터 전송 ex) 리피터, 케이블, 허브 데이터링크 : 물리 계층으로 송수신되는 정보 관리, Mac 주소로 통신 ex) 브릿지, 스위치 네트워크 : 데이터를 목적지까지 전달, 라우터로 경로를 선택해 IP 지정, 경로에 따라 패킷 전달 ex) 라우터, IP 전송 : 통신을 활성화 ex) TCP, UDP 세션 : 데이터가 통신하기 위한 논리적 연결 담당 ex) API, Socket 표현 : 데이터 표현에 대한 독립성을 제공하고 암호화 ex) JPEG, MPEG 응용 : 최종 목적지, 응용프로그램과 연관하여 서비스 수행 ex) HTTP, FTP, DNS"
    },
    {
        "질문": "TCP/IP 4계층에 대해서 설명해주세요.",
        "답변": "1계층 네트워크 액세스 : 물리+데이터링크, MAC주소 사용 2계층 인터넷 : 네트워크, 통신 노드간의 IP패킷을 전송하는 기능과 라우팅 기능 담당 3계층 전송 : 전송, 통신 노드간의 연결 제어 및 신뢰성 있는 데이터 전송 담당 4계층 응용 : 세션+표현+응용, 응용 프로그램 구현"
    },
    {
        "질문": "DNS가 무엇인가요?",
        "답변": "IP주소를 문자로 표현한 주소로 바꾸는 시스템 혹은 서버"
    },
    {
        "질문": "www.naver.com에 접속할때 일어나는 일에 대해 설명해주세요.",
        "답변": "사용자가 브라우저에 도메인 네임( www.naver.com)을 입력 한다. 사용자가 입력한 URL 주소 중에서 도메인 네임(Domain Name) 부분을 DNS 서버에서 검색 하고, DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달 한다. 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성 하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송 된다. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색 한다. 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성 하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송 된다. 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환 되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다."
    },
    {
        "질문": "도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.",
        "답변": "Recursive Query를 통해 접근 : Local DNS 서버 -> Root DNS 서버 -> com DNS 서버 -> naver.com DNS 서버 로컬 DNS서버에 해당 url이 등록되어있는지 확인 루트 DNS서버에 문의 후 최상위 도메인 .com이 등록된 네임 서버의 IP주소 전달 로컬 DNS서버는 com DNS 서버에 해당 url을 문의함. 로컬 DNS서버에 naver.com DNS 서버의 IP 주소 알려줌 naver..com에 해당 url 문의함. 로컬 DNS는 IP 주소를 받을수있음"
    },
    {
        "질문": "유니캐스트, 멀티캐스트, 브로드캐스트란?",
        "답변": "유니캐스트 : 특정 대상과 1:1 통신 멀티캐스트 : 특정 다수와 1:N 통신 브로드캐스트 : 네트워크에 있는 모든 대상과 통신"
    },
    {
        "질문": "TCP와 UDP의 차이에 대해서 설명해 주세요.",
        "답변": "TCP 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜 흐름제어, 혼잡제어, 오류제어 지원 연결 설정시 3 way handshake를, 연결 해제시 4 way handshake 진행 UDP보다 속도가 느리다 EX) 웹 http 통신, 이메일, 파일 전송 UDP 데이터를 데이터그램 단위로 처리하는 프로토콜 신뢰성 낮음 속도가 빠르고 부하가 적다 EX) Real Time Protocol(RTP), Multicast, DNS"
    },
    {
        "질문": "MTU가 무엇인가요?",
        "답변": "Maximum Transmission Unit 패킷이나 프레임의 최대 크기 데이터의 크기가 크다면 단편화해야함"
    },
    {
        "질문": "3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.",
        "답변": "3 way handshake TCP/IP 프로토콜을 사용해 통신을 진행할떄, 두 종단간 정확한 데이터 전송 보장하기 위해 연결을 설정 SYN(Synchronize Sequence Number) ACK(Acknowledgement) 클라이언트 → 서버 : 서버 접속 요청 SYN 패킷 보냄 서버 → 클라이언트 : 요청 수락 응답 ACK 패킷 과 포트 열어달라는 SYN 패킷 보냄 클라이언트 → 서버 : 확인 응답으로 ACK 패킷 보냄 사진 4 way handshake 연결 설정 해제함 클라이언트 → 서버 : 연결 해제하겠다는 FIN 패킷 보냄 서버 → 클라이언트 : 응답으로 ACK 패킷 보냄 서버 → 클라이언트 : 처리해야할 모든 통신 끝내고 연결 종료하겠다는 FIN 패킷 보냄 클라이언트 → 서버 : 확인 응답으로 ACK 패킷 보냄 사진"
    },
    {
        "질문": "HTTP와 HTTPS 의 차이는 무엇인가요?",
        "답변": "HTTP는 인터넷 상에서 클라이언트와 서버가 자원을 주고받기 위한 통신규약인데, 텍스트로 자원을 주고받기 때문에 네트워크를 가로챈다면 내용이 유출되는 보안 이슈가 발생할 수 있습니다. 이를 해결하는 것이 HTTPS입니다. HTTPS에 SSL 프로토콜을 사용해 정보를 암호화하는데, 메모리나 리소스를 더 많이 쓸 수 있다는 특징이 있습니다."
    },
    {
        "질문": "keep-alive 헤더에 대해서 설명해 주세요.",
        "답변": "HTTP는 매번 연결을 끊고 새로 생성함 HTTP 1.1부터는 Keep/alive를 지원 특정 시간까지는 access가 없더라도 기다리고 연결된 상태를 유지함, 이미 열려있는 곳에 요청"
    },
    {
        "질문": "HTTP GET과 POST의 차이는 무엇인가요?",
        "답변": "GET : 정보 요청, body에 담지않고 쿼리로 전송 POST : 데이터를 body에 담아서 리소스를 생성하거나 변경"
    },
    {
        "질문": "쿠키와 세션에 대해서 설명해 주세요.",
        "답변": "쿠키 : 클라이언트의 웹 브라우저가 지정하는 메모리/하드디스크 세션 : 서버의 메모리에 저장"
    },
    {
        "질문": "www.google.com에 접속할때 일어나는 일에 대해 설명해주시겠습니까?",
        "답변": "www.google.com을 브라우저 주소창에 친다. 브라우저는 캐싱된 DNS 기록을 통해 www.google.com에 대응되는 IP 주소가 있는지 확인한다. 브라우저 캐시 확인 OS 캐시 확인 라우터 캐시 확인 ISP 캐시 확인 요청한 URL이 캐시에 없으면 ISP의 DNS 서버가 www.google.com을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날림 브라우저가 IP 주소를 받으면 서버와 TCP 연결을 한다. (3 way handshaking) TCP 연결이 완료되면 브라우저가 웹 서버에 HTTP 요청을 한다. GET 요청을 통해 www.google.com의 웹페이지를 요구한다. 서버가 요청을 처리하고 response를 생성한다. 서버가 HTTP response를 보낸다. 브라우저가 HTML content를 보여준다. [번역] Browser에 www.google.com을 검색하면 어떤 일이 일어날까? 개발자라면 인터넷이 어떻게 작동을 하고 정보들이 어떻게 주고 받아지는지 기본적으로 이해하는 것이 필요하다고 생각해서 공부할 겸 미디움 블로그를 번역했다. ** 내용 조금 수정 및 추가한 부분 있음 검색할 것이 있어서 www.google.com 에 접속을 하려고 할 때 웹페이지가 어떻게 불러와지는지 순서대로 설명을 하려고 한다. DNS(Doman Name System)은 URL들의 이름과 IP주소를 저장하고 있는 데이터베이스이다. https://devjin-blog.com/what-happen-browser-search/"
    },
    {
        "질문": "웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요.",
        "답변": "웹 브라우저가 URL해석->URL이 문법맞으면 Punycode encoding을 url의 host부분에 적용-> HSTS (HTTP Strict Transport Security 목록 로드해서 체크 ->DNS 확인-> ARP로 IP/MAC 확인 ->TCP 통신을 통해 Socket을 열고 .HTTP 프로토콜로 요청 -> HTTP 서버가 응답 ->  웹 브라우저가 그린다."
    },
    {
        "질문": "웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?",
        "답변": "웹 서버 항상 동일한 데이터를 주는 정적 콘텐츠를 제공 동적 콘텐츠 제공을 위해 WAS에 클라이언트의 요청을 보내고 결과를 전달 정적 콘텐츠만 처리해 서버 부담을 줄임 웹 어플리케이션 서버(WAS) 동적인 컨텐츠를 제공 DB 접속/트랜잭션 관리/비즈니스 로직 수행 요청에 맞는 콘텐츠를 제공하기 위해 필요함, 단순한 정적 콘텐츠는 웹 서버에 맡겨 부하를 줄임"
    },
    {
        "질문": "REST API에 대해서 설명해 주세요.",
        "답변": "HTTP를 통해 자원을 주고 받을 때 HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 자원의 CRUD를 수행하는 것을 말합니다."
    },
    {
        "질문": "REST ful에 대해 설명해주시겠습니까?",
        "답변": "REST의 원리를 따르는 시스템을 말합니다. RESTful하지 못한 경우로는 (1) CRUD 기능을 POST로만 처리하는 경우나 (2) URI에 resource, id 외의 정보가 들어가는 경우입니다."
    },
    {
        "질문": "흐름제어 / 혼잡제어 / 오류제어에 대해 설명해주시겠습니까?",
        "답변": "흐름제어 는 송신측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 기법입니다. 혼잡제어 는 송신측의 데이터 전달과 처리 속도 차이를 해결하는 기법입니다. 오류제어 는 패킷이 잘못 전달됐을 경우 패킷을 재전송하는 등 오류를 복구하는 기법입니다. 흐름제어 송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)를 해결하기 위한 기법 송신측의 패킷 전송량 제어해서 수신측의 버퍼 오버플로우 방지 오류제어 오류 검출과 재전송 프레임이 손상되었거나 손실되면 재전송해서 오류 복구 혼잡제어 송신측의 데이터 전달과 데이터 처리 속도를 해결하기 위한 기법 네트워크 혼잡 제어를 피하기 위해 데이터의 전송 속도 제어"
    },
    {
        "질문": "WebRTC에 대해 설명해주시겠습니까?",
        "답변": "어플리케이션(최근에는 Android 및 IOS도 지원) 및 사이트들이 별도의 소프트웨어 없이 음성, 영상 미디어 혹은 텍스트, 파일 같은 데이터를 브라우져끼리 주고 받을 수 있게 만든 기술"
    },
    {
        "질문": "프로세스와 스레드의 차이는 무엇인가요?",
        "답변": "프로세스는 컴퓨터에서 실행중인 프로그램을 말하고 고유한 공간과 자원을 할당 받아 사용합니다.  반면 스레드는 프로세스 안에서 실행되는 여러 흐름의 단위로 프로세스 내의 자원을 공유하고 고유한 stack만을 각자 할당 받습니다."
    },
    {
        "질문": "멀티 스레드 vs 멀티 프로세스에 대해 설명해주시겠습니까?",
        "답변": "멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있다. 반면, 멀티 프로세싱 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다"
    },
    {
        "질문": "스택을 스레드마다 독립적으로 할당하는 이유는 무엇인가요?",
        "답변": "스택은 함수 호출시 전달되는 인자, 복귀 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간입니다. 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능함을 의미하고 이는 독립적인 실행 흐름이 추가된다는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당하는 것이다."
    },
    {
        "질문": "PC 레지스터를 스레드마다 독립적으로 할당하는 이유는 뭘까?",
        "답변": "PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타내게 된다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다."
    },
    {
        "질문": "멀티 프로세스 대신 멀티 스레드를 사용하는 이유는?",
        "답변": "프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이기 때문이다. 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다 . Context Switching시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠르다 .-> 스레드는 Stack 영역만 초기화하면 되기 때문이다. 스레드는 프로세스 내의 메모리를 공유하기 때문에 데이터 전달이 간단하므로 IPC에 비해 비용이 적고 더 빠르다 . -> 스레드는 프로세스의 Stack 영역을 제외한 모든 메모리를 공유하기 때문이다."
    },
    {
        "질문": "컨텍스트 스위칭(Context Switching)이란 무엇인가요?",
        "답변": "여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어 적용하는 과정을 말한다."
    },
    {
        "질문": "컨텍스트 스위칭의 과정에 대해 설명해주시겠습니까?",
        "답변": "Task의 대부분 정보는 Register에 저장되고 PCB로 관리된다. 현재 실행하고 있는 Task의 PCB 정보를 저장한다. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다."
    },
    {
        "질문": "교착상태(Dead Lock)란 무엇인가?",
        "답변": "교착 상태는 자원을 여러 곳에서 사용하려고 할 때 발생하는 문제이다. 서로 원하는 자원이 상대방에게 할당되어 있어 두 프러세스가 무한정 wait 상태에 빠지게 되는 상황."
    },
    {
        "질문": "교착상태가 발생하기 위한 조건은?",
        "답변": "4가지 중 하나라도 성립하지 않으면 데드락은 발생하지 않습니다. 상호 배제(Mutual exclusion) : 자원은 한번에 한 프로세스만 사용할 수 있음 점유 대기(Hold and wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함 비선점(No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음 순환 대기(Circular wait) : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함"
    },
    {
        "질문": "교착상태의 해결법은 무엇인가요?",
        "답변": "예방(prevention) 교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함) 상호배제 부정 : 여러 프로세스가 공유 자원 사용 점유대기 부정 : 프로세스 실행전 모든 자원을 할당 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구 회피(avoidance) - 교착 상태 발생 시 피해나가는 방법 은행원 알고리즘(Banker's Algorithm) 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있으면 자원할당, 아니면 할당을 거부하고 다른 프로세스 들이 자원을 해지할때까지 대기하는 방법 탐지(Detection) & 회복 은행원 알고리즘과 유사한 방식 vs 자원 할당 그래프를 통해 교착 상태를 탐지함 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함 회복(Recovery) - 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법 프로세스 종료 방법 교착 상태의 프로세스를 모두 중지 교착 상태가 제거될 때까지 하나씩 프로세스 중지 자원 선점 방법 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴) 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점 무시"
    },
    {
        "질문": "회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.",
        "답변": "은행원 알고리즘은 은행에서 현금을 할당하는 것에서 유래한 알고리즘입니다. 프로세스가 자원을 요구할때 자원을 할당한 후에도 안정 상태이면 자원을 할당하고, 그렇지 않으면 다른 자원이 해제될때까지 대기했다가 자원을 할당합니다."
    },
    {
        "질문": "은행원 알고리즘의 단점는 무엇인가요?",
        "답변": "할당할 수 있는 자원수가 일정 해야함 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다 최대 자원 요구량 을 미리 알아야 한다. 프로세스들은 유한한 시간 안에 자원을 반납해야 한다."
    },
    {
        "질문": "기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.",
        "답변": "일정 시간 생각을 한다. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다. 오른쪽 포크를 내려놓는다. 왼쪽 포크를 내려놓는다. 다시 1번으로 돌아간다."
    },
    {
        "질문": "철학자 문제 교착상태 조건 성립 조건에 대해 설명해주시겠습니까?",
        "답변": "상호 배제 -> 젓가락은 한 번에 한 철학자만 사용할 수 있습니다. 점유와 대기 -> 왼쪽 젓가락을 점유하면서 오른쪽 젓가락을 대기합니다. 비선점 -> 이미 누군가가 집어 든 젓가락을 강제로 뺏을 수 없습니다. 환형 대기 -> 모든 철학자들이 오른쪽에 앉은 철학자가 젓가락을 놓기를 기다립니다."
    },
    {
        "질문": "식사하는 철학자 문제 해결책에 대해 설명해주시겠습니까?",
        "답변": "모두 젓가락을 내려두고 랜덤시간동안 기다린 다음 식사 (기아현상이 발생할 수 있는 가능성이 남아 있음) 뮤텍스 - (화장실이 하나밖에 없는 식당) 공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것 식사할 수 있는 상황을 하나의 key로 관리 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있다. 그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다. Critical Section을 가진 쓰레드들의 Running tme이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술 세마포어 - (화장실이 여러개인 식당) 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것 Signaling mechanism. 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법 락을 걸지 않은 쓰레드도 Signal을 보내 락을 해제할 수 있다는"
    },
    {
        "질문": "Mutex vs Semaphore에 대해 설명해주시겠습니까?",
        "답변": "세마포어와 뮤텍스는 동기화 문제를 해결하기 위한 방법입니다. 여러 프로세스가 공유자원에 접근할때, 한 프로세스가 크리티컬 섹션에서 수행중이라면 다른 프로세스는 자신의 크리티컬 섹션에 들어가지 못하게 해야합니다. 세마포어 에는 P연산과 V연산이 있습니다. P연산은 자원을 할당하는 연산이고 V연산은 자원을 해제하는 연산입니다. 크리티컬 섹션에 들어가기 전 세마포어를 통해 자원에 접근가능한지 확인을 하며 동기화문제를 해결합니다. 공유 자원에 프로세스들이 최대 허용치만큼 접근할 수 있음 뮤텍스 는 이진 세마포어의 일종으로 자원에 lock을 걸면서 동기화 문제를 해결합니다. 상호 배제 개념을 이용하며 크리티컬 섹션을 가진 스레드들이 각각 단독으로 실행되게 하는 기술입니다."
    },
    {
        "질문": "임계구역이란?",
        "답변": "여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분"
    },
    {
        "질문": "경쟁 상태(Race Condition)란 무엇인가요?",
        "답변": "두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황"
    },
    {
        "질문": "경쟁상태가 발생하는 경우에 대해 설명해주시겠습니까?",
        "답변": "커널 작업을 수행하는 중에 인터럽트 발생 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다. 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 ) 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법"
    },
    {
        "질문": "경쟁상태를 방지하기 위한 해결법의 충족 조건에 대해 설명해주시겠습니까?",
        "답변": "Mutual Exclusion (상호 배제) 어떤 프로세스 가 임계 영역을 수행 중이면 다른 모든 프로세스들은 그 임계 영역에 들어가면 안된다. Progress 아무도 임계 영역에 있지 않은 상태에서 임계 영역에 들어가려는 프로세스가 있으면 들어가게 해주어야 한다. ( livelock 방지 ) Bounded Waiting 프로세스가 임계 영역에 들어가려고 요청한 후부터 다른 프로세스들이 임계 영역에 들어가는 횟수에 한계가 있어야 한다 ( starvation 방지 )"
    },
    {
        "질문": "경쟁상태 해결방법은 무엇이 있나요?",
        "답변": "상호배제 동기화 세마포어 모니터 락"
    },
    {
        "질문": "프로세스 혹은 스레드의 동기화란 무엇인가요?",
        "답변": "동기화란 병렬적으로 수행되는 작업들에 대해 자원 접근 순서를 정해 서로가 알고있는 정보가 일치하도록 하는 것"
    },
    {
        "질문": "사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?",
        "답변": "커널 수준 스레드 스레드를 생성하고 스케줄링하는 주체가 커널 장점 : 커널이 직접 제공해주므로 안정성과 다양한 기능 제공 단점 : 유저 모드에서 커널 모드로의 전환이 빈번함 사용자 수준 스레드 스레드 기능을 제공하는 라이브러리를 이용하므로 커널에 의존하지 않음 장점 : 커널이 스레드를 모르기때문에 모드 간의 전환이 없고 성능 이득 발생 단점 : 하나의 스레드가 커널에 블로킹되면 프로세스 전체가 블로킹됨"
    },
    {
        "질문": "CPU 스케줄링이란 무엇인가요?",
        "답변": "CPU 스케줄링이란 CPU를 배정하는 것을 말한다. 오버헤드, 기아현상, 소요시간, 반환시간, 대기시간 낮추기 처리량, 사용률, 응답 시간 높이기 선점 스케줄링 : OS가 CPU의 사용권을 빼앗을 수 있음 비선점 스케줄링 : CPU를 빼앗을 수 없음"
    },
    {
        "질문": "프로세스 스케줄러에는 어떤 것들이 있나요?",
        "답변": "장기 스케줄러 : 어떤 프로세스를 ready queue에 보낼지, 시분할 시스템에서는 잘 안둠 단기 스케줄러 : 어떤 프로세스를 실행시킬지 중기 스케줄러 : 메모리에 공간이 부족한 경우 어떤 프로세스를 swap out할지"
    },
    {
        "질문": "CPU 스케줄링의 성능 척도에는 어떤 것들이 있나요?",
        "답변": "CPU Utilization(이용률) : 전체 시간 중 CPU가 놀지 않고 일한 시간, 이용률이 높을수록 좋음 Throughput(처리량) : 단위 시간당 처리량, CPU가 얼마나 많은 일을 했는가, 높을수록 좋음 Turnaround Time(소요시간, 반환시간) : CPU 사용한 시간 + 기다린 시간, 짧을수록 좋음 Waiting Time(대기시간) : 프로세스가 Ready Queue에서 기다린 전체 시간의 합, 짧을수록 좋음 Response Time(응답시간) : 프로세스가 Ready Queue에 들어가서 최초로 CPU 얻기까지의 시간, 짧을수록 좋음"
    },
    {
        "질문": "CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?",
        "답변": "선점 스케줄링 우선순위 스케줄링 : 우선순위가 높은 순서대로 처리 Round Robin : 동일한 시간의 time quantum만큼 할당 Multilevel Queue : 작업을 여러 종류의 큐로 나누어 큐마다 다른 time quantum 할당 Multilevel-feedback Queue : Multilevel에서 time quantum을 채우면 다음 level로 내려감 비선점 스케줄링 FCFS : 큐에 도착한 순서대로 CPU 할당 SJF : 수행시간이 짧은 것 부터 CPU 할당"
    },
    {
        "질문": "동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?",
        "답변": "동기/비동기 - 작업 주체 여러개 블로킹/논블로킹 - 작업이 여러개 동기 : 시작과 종료를 동시에 하거나, 하나가 끝나면 다른 하나가 시작하는 경우 비동기 : 별도의 시작/종료를 가짐 블로킹 : 작업을 하다가 다른 작업이 완료될때까지 기다렸다가 다시 수행 넌블로킹 : 다른 작업과 관련없이 자기 작업 계속함"
    },
    {
        "질문": "IPC란 무엇인가요?",
        "답변": "IPC는 Inter-Process Communication의 약자로 프로세스간 통신을 의미합니다. 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있습니다. IPC설비의 종류는 여섯 가지가 있습니다. 첫번째는, PIPE (익명 파이프) 입니다. PIPE는 두 프로세스간 파이프를 연결해서 통신을 하는 방식입니다. 여기서 한 프로세스는 쓰기만 가능하고 다른 프로세스는 읽기만 가능하다는 특징이 있습니다. 한쪽 방향으로만 통신이 가능하기 때문에 반이중 통신이라고 부르기도 합니다. PIPE는 간단하게 사용할 수 있다는 장점이 있습니다. 두번째는, Named PIPE (FIFO) 입니다. PIPE는 통신하는 프로세스가 명확할 경우 사용하는 반면, Named PIPE는 전혀 모르는 사이의 프로세스들의 통신에 사용합니다. 익명 PIPE는 부모가 동일한 프로세스들 사이에서만 통신이 가능하지만 Named PIPE는 부모 프로세스에 상관없이 프로세스들 사이의 통신을 할 수 있다는 점이 특징입니다. 이는 프로세스 통신을 위해 mkfifo함수를 이용해 파일을 생성하기 때문에 가능합니다. 하지만, 익명 PIPE와 동일하게 동시에 읽기/쓰기가 불가능 합니다. 이는 두개의 파일을 읽기전용, 쓰기전용으로 만들어서 해결할 수 있습니다. 전이중 통신을 위해서는 두 개의 fifo 파일을 만들어서 사용해야 합니다. 세번째는, 메세지 큐 입니다. 메세지 큐는 선입선출의 형태로 통신이 이루어지는 점에서 Named PIPE와 동일합니다. 차이점은 Named PIPE가 데이터의 흐름이라면 메세지 큐는 메모리 공간이라는 점입니다. 이는 여러개의 프로세스가 메세지 큐의 데이터에 접근할 수 있음을 의미합니다. 네번째는, 공유메모리 입니다. 앞서 PIPE, Named PIPE, 메세지 큐가 통신을 이용해 데이터를 주고받는다면, 공유메모리는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 지원합니다. 프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해줍니다. 이후 어떤 프로세스건 해당 메모리영역에 접근할 수 있습니다. 공유 메모리는 곧바로 메모리에 접근할 수 있기 때문에 IPC 방식 중 속도가 제일 빠릅니다. 다섯번째는, 메모리 맵 입니다. 메모리 맵은 공유 메모리와 메모리를 공유한다는 점은 동일합니다. 하지만, 현재 열려져 있는 파일을 공유하는 점에서 차이가 있습니다. 열린 파일이 메모리에 올라가있으면 다른 프로세스가 해당 파일을 사용할 때 또다시 파일을 열지않고 공유한 상태로 사용하는 것이 더 효율적입니다. 여섯번째는, 소켓입니다. 소켓은 소켓을 만들어 통신하는 방법입니다. 소켓 통신은 데이터 교환을 위해 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고받는 방식입니다. 이 때 각각 PC의 프로세스는 임의의 PORT를 맡아 데이터를 송수신 합니다."
    },
    {
        "질문": "child process와 zombi process에 대해 설명해 보시오. (고아/좀비)에 대해 설명해주시겠습니까?",
        "답변": "자식 프로세스 : fork로 자식프로세스를 만든 상태. 부모의 데이터,힙,스택, PCB 복사 좀비 프로세스 : 프로세스가 종료됐는데 메모리상에 정보가 남아있는 상태, 부모가 wait로 보고받지 못함 고아 프로세스 : 부모 프로세스가 먼저 종료돼서 부모 프로세스를 잃은 프로세스, init이 자식프로세스 회수함"
    },
    {
        "질문": "인터럽트란 무엇인가요?",
        "답변": "인터럽트란 프로세스 실행 중에 예외상황이 발생하여 처리가 필요한 경우 CPU에게 알려 처리할 수 있도록 하는 것을 말합니다. 폴링은 대상을 주기적으로 감시하여 상황이 발생하면 해당 루틴을 처리합니다. 인터럽트란 CPU가 프로그램을 실행하고 있는 도중에 입출력 요청 또는 예외상황을 처리해야 하면 실행하던 프로그램을 멈추고 CPU가 해당 작업을 처리하도록 하는 것을 말합니다. 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 구성되어 있습니다. 하드웨어 인터럽트는 하드웨어 기기가 인터럽트를 요청하는 것이고 소프트웨어 인터럽트는 예외처리, 시스템 콜이 발생하는 상황에서 실행됩니다."
    },
    {
        "질문": "시스템 콜이란 무엇인가요?",
        "답변": "시스템 콜은 사용자나 응용 프로그램이 커널에서 제공하는 기능을 사용하기 위한 인터페이스 입니다. 운영체제는 커널이 제공하는 서비스를 시스템콜을 이용해 제한함으로써 컴퓨터 자원을 보호합니다. 예시로는 프로세스 생성/종료나 I/O작업 등이 있습니다. (fork, exec, exit, wait)"
    },
    {
        "질문": "전통적인 동기화 문제에는 어떤 것들이 있나요?",
        "답변": "1. Bounded- Buffer Problem 2. Readers and Writers Problem 3. Dining Philosophers Problem"
    },
    {
        "질문": "프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.",
        "답변": "코드 : 실행할 명령어 저장 데이터 : 프로그램에 필요한 전역변수나 정적변수 저장 스택 : 함수 호출에 필요한 스택 프레임 저장 힙 : 사용자가 관리하는 공간으로 메모리가 동적으로 할당되고 해제됨, JAVA에서는 GC가 메모리를 알아서 해제해줌"
    },
    {
        "질문": "메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.",
        "답변": "레지스터, 캐시, 주기억장치, 보조기억장치 순서입니다. CPU는 프로그램 실행 시 먼저 레지스터에 필요한 데이터가 있는지 확인합니다. 레지스터에 필요한 데이터가 존재하지 않는다면 캐시를, 캐시에도 없다면 주기억장치를, 주기억장치에도 없다면 보조기억장치를 확인하며 필요한 데이터를 적재합니다. https://popcorntree.tistory.com/68 레지스터 : CPU 내에 존재하는 메모리로 빠르고 작다. 캐시 : CPU와 주기억장치 사이에서 중간 저장소 역할을 함. Locality 특성 이용 주기억장치 : 현재 수행되는 프로그램과 데이터 저장 보조기억장치 : 용량이 크나 느리다."
    },
    {
        "질문": "페이지와 세그멘테이션에 대해서 설명해 보시오.",
        "답변": "메모리를 관리 기법 중 불연속 메모리 관리 기법입니다. 페이징은 외부단편화와 압축 작업을 해결하기 위한 방법으로, 페이지라는 고정 크기로 logical memory를 분리하고, 페이지와 같은 크기의 프레임으로 physical memory를 분리합니다. 페이징을 사용하면 외부 단편화를 해결한다는 장점이 있지만 내부단편화는 여전히 존재합니다. 세그멘테이션은 페이징과는 달리 서로 다른 크기의 논리적 단위인 세그먼트로 메모리를 분리합니다. 세그멘테이션을 사용하면 세그먼트들이 메모리에 할당되고 해제되는 과정에서 외부단편화가 발생합니다. 하지만 세그먼트는 메모리를 의미 단위로 나누기 때문에 보호와 공유에서 효율적입니다. 메모리 관리 기법 연속 메모리 관리 : 고정 분할(내부단편화), 동적 분할(외부단편화) 불연속 메모리 관리 : 페이징, 세그멘테이션"
    },
    {
        "질문": "외부 단편화란? 내부 단편화란?",
        "답변": "내부 단편화 란 프로세스가 사용하는 메모리 공간 중 남는 부분이 발생하는 현상입니다. 외부 단편화 란 physical memory 사이에 사용하지 못하는 공간이 생기는 현상을 말합니다."
    },
    {
        "질문": "메모리의 First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.",
        "답변": "First fit : 메모리의 처음부터 검사해서 크기가 충분한 첫번째 메모리에 할당 Next fit : 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾음 Best fit : 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당"
    },
    {
        "질문": "페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?",
        "답변": "OPT : 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 (실현 가능성 희박) FIFO : 메모리가 할당된 순서대로 페이지를 교체 LRU : 최근에 가장 오랫동안 사용하지 않은 페이지를 교체 LFU : 사용 빈도가 가장 적은 페이지를 교체 NUR : 최근에 사용하지 않은 페이지를 교체"
    },
    {
        "질문": "가상 메모리(Virtual Memory)란?",
        "답변": "메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법 프로그램에 실제 메모리 주소가 아닌 가상 메모리 주소를 할당하는 방법"
    },
    {
        "질문": "Demand Paging이란?",
        "답변": "현재 필요한 부분만 메모리에 적재하는 것 페이지가 올라와있는지 구별시에는 유효-무효 비트를 사용함"
    },
    {
        "질문": "Cache Memory의 역할은 무엇인가요?",
        "답변": "캐시 메모리는 CPU와 메모리 사이의 속도 차이를 완화하기 위한 역할을 합니다. 캐시는 메모리의 데이터를 미리 가져와 저장해두는 임시 장소로 앞으로 사용될 것으로 예상되는 데이터를 미리 저장해 놓습니다."
    },
    {
        "질문": "Caching Locality와 Cache Hit Ratio에 대해 설명해주시겠습니까?",
        "답변": "캐시 적중률 은 CPU가 사용할 데이터를 캐시에서 탐색 했을 때, 원하는 데이터가 캐시에 존재할 확률을 의미합니다. 캐시 적중률 을 높이기 위해서는 캐시 메모리의 크기를 늘리는 방법과 앞으로 많이 사용될 데이터를 캐시에 저장하는 방법이 있습니다. 앞으로 많이 사용될 데이터를 저장하기 위해서는 캐시 지역성 을 이용할 수 있습니다. 캐시 지역성은 현재 사용하고 있는 메모리 위치에서 가까운 데이터를 사용할 확률이 높다는 개념입니다. 따라서, 현재 접근하고 있는 메모리 근처의 값들을 캐시에 저장해놓는다면 캐시 적중률을 높일 수 있습니다."
    },
    {
        "질문": "Call Stack에 대해 설명해주시겠습니까?",
        "답변": "컴퓨터 프로그램에서 현재 실행 중인 서브루틴에 관한 정보를 저장하는 스택 자료구조"
    },
    {
        "질문": "Heap과 Stack의 장단점 비교 (속도, 크기 등)에 대해 설명해주시겠습니까?",
        "답변": "스택 : 빠르다, 스택 크기 제한 힙 : 메모리 크기 제한 없음, 메모리를 직접 관리해야함, 상대적으로 느림"
    },
    {
        "질문": "Memory Corruption이란?",
        "답변": "버그로 인한 메모리 오염, 예상되지 않은 메모리 값 변경 등에 의해 일어남"
    },
    {
        "질문": "DMA란?",
        "답변": "CPU를 대신하여 I/O장치와 Memory사이의 데이터전송을 담당하는 장치 주변장치(하드디스크, 그래픽카드)들이 메모리에 직접 접근하여 읽거나 쓰도록 하는 기능 CPU의 개입 없이 I/O장치와 기억장치 사이의 데이터를 전송할수있음 인터럽트 발생 횟수 최소화하여 성능 높임"
    },
    {
        "질문": "Rx에서 새로운 스레드를 생성해도 되는데 왜Schedulers.io() 를 사용하는가?",
        "답변": "IO 스케줄러는 필요할때마다 스레드를 생성함 뉴스레드는 요청받을때마다 스레드 생성함 많은 스레드가 생성되면 전체 성능에 영향 줄수있음"
    },
    {
        "질문": "배압 현상이란?",
        "답변": "생산과 소비가 불균형적일때 일어나는 현상 데이터를 발행하는 속도를 소비가 못 따라감 메모리가 Overflow되고 OOME 가능성"
    },
    {
        "질문": "Observable vs Flowable에 대해 설명해주시겠습니까?",
        "답변": "Observable 데이터 흐름에 맞게 알림을 보냄 Observer는 이를 구독해 데이터가 준비되면 반응함 Flowable 배압 현상을 제어할 수 있음 일정량 이상의 데이터가 쌓이면 더이상 발행하지않음"
    },
    {
        "질문": "zip merge combineLast에 대해 설명해주시겠습니까?",
        "답변": "zip : 두 스트림에서의 데이터를 하나로 합쳐줌 merge : 두 스트림을 하나의 스트림으로 combineLast : 두 스트림의 마지막 데이터끼리 합쳐줌"
    },
    {
        "질문": "map과 flatMap 차이는 무엇인가요?",
        "답변": "flatMap은 Observable을 반환"
    },
    {
        "질문": "객체지향이 무엇인가요? 절차지향과의 차이점은 뭐죠?",
        "답변": "객체지향(OOP; Object Oriented Programming) : 현실세계를 기반해서 모델링하는 프로그래밍 기법 - 세부모델부터 디자인하는 Bottom-UP 방식 - 추상화, 캡슐화, 상속, 다형성 장점 : 코드 재활용성 높음, 디버깅 쉬움 단점 : 처리속도가 절차지향보다 느림, 언어 : JAVA, Python, C# 절차지향(PP; Procedural Programming) : 프로시저 호출의 개념을 바탕으로 하는 프로그래밍 기법 - 데이터와 함수를 별개로 처리함 - 큰 기능을 작은 단위로 나누어 처리하는 Top-Down 방식 장점 : 실행 속도 빠름 단점 : 유지보수 어려움, 디버깅 어려움 언어 : C, Portran, Basic"
    },
    {
        "질문": "객체지향 4가지 특징에 대해서 설명해 주세요.",
        "답변": "추상화 추상적인 개념에 의존해서 설계 사물의 공통적인 특징을 도출함 캡슐화 실제 구현 내용을 감추는 것 낮은 결합도를 유지할 수 있도록 설계하는 것 정보은닉의 개념을 활용함 변경이 일어나도 다른 모듈에 영향을 최소화할 수 있음 상속 이미 정의된 부모 클래스의 메소드와 속성을 자식 클래스가 물려받는 것 재사용성 높아짐 단점 : 부모 클래스의 변경이 어려워진다 → IS-A 관계가 성립할때만 상속함으로써 해결 다형성 오버로딩, 오버라이딩과 관련 구체적으로 어떤 클래스의 객체가 참조되는 지와 무관하게 여러 형태를 받아들임으로써 프로그래밍 가능"
    },
    {
        "질문": "클래스, 객체, 인스턴스 차이에 대해서 설명해 주세요.",
        "답변": "클래스 : 객체를 만들어내기 위한 설계도나 틀, 연관되어 있는 메소드나 변수의 집합 객체 : 클래스의 인스턴스 , 구현할 대상 인스턴스 : 구현된 구체적인 실체, 메모리에 할당됨, 메모리에 생성한 객체 클래스는 연관된 여러 데이터와 메소드로 이루어진 집합체를 말합니다. 객체는 클래스의 구현해야할 대상을 말하고 인스턴스는 메모리에 할당된 구현된 실체를 말합니다."
    },
    {
        "질문": "순수 추상 클래스와 인터페이스의 차이는 무엇인가요?",
        "답변": "추상 클래스 추상 메소드를 한 개 이상 포함한 클래스 서브 클래스에게 추상 메소드의 구현을 강제함 기능을 확장 하는 데에 목적 인터페이스 추상메소드와 변수로만 이루어짐 서브 클래스에게 메소드의 원형을 알려주어 자신의 목적에 맞게 메소드를 구현할 수 있게 함 공통점 인스턴스 생성 불가능 서브 클래스가 기능을 구현하도록 책임을 위임함 차이점 추상클래스는 클래스 O, 인터페이스는 클래스 X 추상클래스는 다중상속 불가능, 인터페이스는 다중상속 가능"
    },
    {
        "질문": "오버로딩과 오버라이딩의 차이는 무엇인가요?",
        "답변": "오버로딩 : 같은 이름을 가진 메소드를 추가하는 것 오버라이딩 : 부모 클래스의 메소드를 자식 클래스가 재정의 하는 것."
    },
    {
        "질문": "업캐스팅과 다운캐스팅이란?",
        "답변": "업캐스팅 서브클래스의 객체가 수퍼클래스로 형변환됨 수퍼클래스 변수로 서브클래스 가리킴 이유 : instanceof 할 필요없이 부모타입으로 가리킬수있음, 코드 재사용성 높임 다운캐스팅 업캐스팅 상태를 원상태로 복구 원래의 서브클래스로 복구. 명시적으로 형변환 이유 : 서브클래스의 각자의 고유기능에 접근하기 위해"
    },
    {
        "질문": "디자인 패턴이란 무엇인가요?",
        "답변": "반복적으로 일어나는 방법론을 어떻게 풀어나갈 것인가에 대한 솔루션"
    },
    {
        "질문": "추상 팩토리 패턴이란?",
        "답변": "생성 패턴 클래스에서 실제 구현부를 정의하지 않고 팩토리 클래스에 인스턴스 생성을 요청함 장점 : 클라이언트 코드와 구현 분리 가능, 객체 간의 일관성 증진, 구현부 쉽게 수정 가능 단점 : 새로운 종류의 product 제공 어려움"
    },
    {
        "질문": "싱글톤 패턴이란?",
        "답변": "생성 패턴 어떤 클래스의 인스턴스는 하나임을 보장함 전역적인 접근점 제공, 공통된 객체를 여러곳에서 접근해야 하는 경우 장점 : 인스턴스로의 접근을 통제, 접근 캡슐화"
    },
    {
        "질문": "빌더 패턴이란?",
        "답변": "생성 패턴 복잡한 객체를 생성하는 클래스와 표현하는 클래스를 분리 복합적인 객체를 생성하는 과정을 세밀하게 분리할 수 있음 생성과 표현을 분리 데이터가 늘어난다면 매번 생성자를 만들어야하는데 그러지않아도됨 명시적이다"
    },
    {
        "질문": "팩토리 메소드 패턴이란?",
        "답변": "생성 패턴 어떤 객체를 생성할지 서브클래스가 결정함 자신이 어떤 객체를 생성해야할지 모를 때"
    },
    {
        "질문": "옵저버 패턴이란?",
        "답변": "행위 패턴 객체의 상태 변화를 관찰해 변화가 발생하면 변화를 통지받고 자동으로 갱신될 수 있게 함 분산 이벤트 핸들링 시스템에 주로 사용 객체가 변경되어야하는데 얼마나 많은 객체들이 변경되어야 하는지 모를 때 장점 : subject와 observer 사이에 추상적인 결합도만 존재"
    },
    {
        "질문": "어댑터 패턴이란?",
        "답변": "구조 패턴 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴 ex) 리사이클러뷰의 어댑터는 데이터 리스트로부터 아이템 뷰를 만들어냄"
    },
    {
        "질문": "애자일 방법론이란?",
        "답변": "반복적인 개발 주기를 통해서 소프트웨어를 개발하는 방법 피드백을 받아서 유동적으로 개발함"
    },
    {
        "질문": "컴파일러와 인터프리터의 차이는 무엇인가요?",
        "답변": "컴파일러 전체 소스코드를 훑으며 명령어를 수집하고 재구성 소스코드를 기계어로 바꿈 OS와 빌드 환경에 종속적 인터프리터 번역시간은 빠르지만 실행시간은 컴파일러보다는 느림 소스코드를 한 줄씩 읽으며 기계어로 바꿈 프로그램 수정이 간단하다"
    }
]