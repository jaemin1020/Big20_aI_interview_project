# ğŸš€ ë²¡í„° ë°ì´í„°ë² ì´ìŠ¤(Vector DB) ì‹¬ì¸µ ê°€ì´ë“œ: êµ¬ì¶•ë¶€í„° í™œìš©, ìµœì í™”ê¹Œì§€

ë³¸ ë¬¸ì„œëŠ” í”„ë¡œì íŠ¸ì—ì„œ **ë²¡í„° ë°ì´í„°ë² ì´ìŠ¤(pgvector)**ë¥¼ í™œìš©í•˜ì—¬ ë¹„ì •í˜• ë°ì´í„°ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³ , ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ AI ë©´ì ‘ ì§ˆë¬¸ ìƒì„±ê³¼ ê°™ì€ ê³ ê¸‰ RAG(Retrieval Augmented Generation) ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ëŠ” ì „ ê³¼ì •ì„ ê¸°ìˆ ì  ê´€ì ì—ì„œ ìƒì„¸íˆ ë¶„ì„í•©ë‹ˆë‹¤. ë°ì´í„° ìˆ˜ì§‘ë¶€í„° ì €ì¥, ê²€ìƒ‰, ê·¸ë¦¬ê³  ì„±ëŠ¥ ìµœì í™” ë° ë³´ì•ˆ ê³ ë ¤ì‚¬í•­ê¹Œì§€ í¬ê´„ì ìœ¼ë¡œ ë‹¤ë£¹ë‹ˆë‹¤.

---

## ğŸ—ï¸ 1. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ë° ê¸°ìˆ  ìŠ¤íƒ (System Architecture & Tech Stack)

ìš°ë¦¬ í”„ë¡œì íŠ¸ëŠ” ë¹„ìš© íš¨ìœ¨ì„±ê³¼ ë°ì´í„° ì •í•©ì„±ì„ ìµœìš°ì„ ìœ¼ë¡œ ê³ ë ¤í•˜ì—¬, ë³„ë„ì˜ ìœ ë£Œ ë²¡í„° DB ì†”ë£¨ì…˜ ëŒ€ì‹  **PostgreSQL + pgvector** ì¡°í•©ì„ í•µì‹¬ ë²¡í„° ì €ì¥ì†Œë¡œ ì±„íƒí–ˆìŠµë‹ˆë‹¤. ì´ ì•„í‚¤í…ì²˜ëŠ” ê¸°ì¡´ ê´€ê³„í˜• ë°ì´í„°ë² ì´ìŠ¤ì˜ ì•ˆì •ì„±ê³¼ ë²¡í„° ê²€ìƒ‰ì˜ ìœ ì—°ì„±ì„ ë™ì‹œì— ì œê³µí•©ë‹ˆë‹¤.

### 1.1 ì•„í‚¤í…ì²˜ ê°œìš”

```mermaid
graph TD
    A[ì‚¬ìš©ì/ì§€ì›ì] --> B(ì´ë ¥ì„œ ì—…ë¡œë“œ)
    B --> C(API Gateway)
    C --> D(Web/App Server)
    D --> E(Celery Task Queue)
    E --> F(AI Worker - Chunking)
    F --> G(AI Worker - Embedding)
    G --> H(AI Worker - PGVector Storage)
    H --> I(PostgreSQL + pgvector)

    J[AI ë©´ì ‘ê´€] --> K(ì§ˆë¬¸ ìƒì„± ìš”ì²­)
    K --> D
    D --> L(AI Worker - RAG Retrieval)
    L --> I
    I --> L
    L --> M(AI Worker - LLM Context Injection)
    M --> N(LLM - EXAONE)
    N --> J
```

### 1.2 í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ

| í•­ëª© | ê¸°ìˆ  ìŠ¤íƒ | ìƒì„¸ ì„¤ëª… |
| :--- | :--- | :--- |
| **Vector DB** | **PostgreSQL (pgvector)** | ì˜¤í”ˆì†ŒìŠ¤ ë²¡í„° í™•ì¥ ëª¨ë“ˆ. ê¸°ì¡´ RDB ì¸í”„ë¼ í™œìš© ë° ë¹„ìš© ì ˆê°. |
| **Embedding Model** | **nlpai-lab/KURE-v1** | í•œêµ­ì–´ ë¬¸ì¥ ìœ ì‚¬ë„ì— íŠ¹í™”ëœ ëª¨ë¸ (1024ì°¨ì›). HuggingFace Transformers ê¸°ë°˜. |
| **Framework** | **LangChain (Community)** | PGVectorì™€ì˜ ìƒí˜¸ì‘ìš©, RAG íŒŒì´í”„ë¼ì¸ êµ¬ì¶•, LLM ì—°ë™ì„ ìœ„í•œ í•µì‹¬ í”„ë ˆì„ì›Œí¬. |
| **Asynchronous Processing** | **Celery (GPU Queue)** | ëŒ€ìš©ëŸ‰ ì´ë ¥ì„œ ì²˜ë¦¬ ë° ë²¡í„° ì—°ì‚°ì˜ ë¹„ë™ê¸° ì²˜ë¦¬ë¥¼ ìœ„í•œ ë¶„ì‚° íƒœìŠ¤í¬ í. GPU ë¦¬ì†ŒìŠ¤ í™œìš©. |
| **LLM** | **EXAONE (Custom)** | ìµœì¢… ì§ˆë¬¸ ìƒì„± ë° ëŒ€í™” íë¦„ ì œì–´ë¥¼ ìœ„í•œ ëŒ€ê·œëª¨ ì–¸ì–´ ëª¨ë¸. |

---

## âš™ï¸ 2. ë°ì´í„° ìˆ˜ì§‘ ë° ì €ì¥ ê³¼ì • (Data Ingestion: PDF â†’ Vector)

ì§€ì›ìê°€ ì´ë ¥ì„œë¥¼ ì—…ë¡œë“œí•˜ë©´, ì‹œìŠ¤í…œì€ ì´ë¥¼ êµ¬ì¡°í™”í•˜ê³ , ì˜ë¯¸ ë‹¨ìœ„ë¡œ ë¶„í• (Chunking)í•œ ë’¤, ìˆ˜í•™ì  ì¢Œí‘œ(Vector)ë¡œ ë³€í™˜í•˜ì—¬ ë²¡í„° DBì— ì €ì¥í•©ë‹ˆë‹¤. ì´ ê³¼ì •ì€ Celeryë¥¼ í†µí•´ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.

### 2.1 â‘  ë°ì´í„° ì²­í‚¹ (Chunking)

ì´ë ¥ì„œ ì „ì²´ë¥¼ í†µì§¸ë¡œ ì„ë² ë”©í•˜ë©´ AIê°€ í•µì‹¬ ì •ë³´ë¥¼ íŒŒì•…í•˜ê¸° ì–´ë µê³ , ê²€ìƒ‰ì˜ ì •ë°€ë„ê°€ ë–¨ì–´ì§‘ë‹ˆë‹¤. ë”°ë¼ì„œ í•™ë ¥, ê²½ë ¥, í”„ë¡œì íŠ¸, ìê¸°ì†Œê°œ ë“± ì˜ë¯¸ ìˆëŠ” ë‹¨ìœ„ë¡œ í…ìŠ¤íŠ¸ë¥¼ ë¶„í• í•˜ëŠ” ê³¼ì •ì´ í•„ìˆ˜ì ì…ë‹ˆë‹¤. `RecursiveCharacterTextSplitter`ì™€ ê°™ì€ ë„êµ¬ë¥¼ í™œìš©í•˜ì—¬ ë¬¸ë§¥ì„ ë³´ì¡´í•˜ë©´ì„œ íš¨ìœ¨ì ìœ¼ë¡œ ì²­í‚¹ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```python
# ai-worker/tasks/resume_embedding.py (ì¼ë¶€)
from langchain.text_splitter import RecursiveCharacterTextSplitter
from typing import List, Dict

def chunk_resume(structured_data: Dict) -> List[str]:
    """
    êµ¬ì¡°í™”ëœ ì´ë ¥ì„œ ë°ì´í„°ë¥¼ ì˜ë¯¸ ë‹¨ìœ„ë¡œ ì²­í‚¹í•©ë‹ˆë‹¤.
    ì˜ˆ: í•™ë ¥, ê²½ë ¥, í”„ë¡œì íŠ¸, ìê¸°ì†Œê°œ ë“±ì„ ê°œë³„ ì²­í¬ë¡œ ë¶„ë¦¬.
    """
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=500,  # ê° ì²­í¬ì˜ ìµœëŒ€ ê¸¸ì´
        chunk_overlap=50, # ì²­í¬ ê°„ ì¤‘ë³µ ê¸¸ì´ (ë¬¸ë§¥ ìœ ì§€ë¥¼ ìœ„í•¨)
        length_function=len,
        add_start_index=True,
    )

    chunks = []
    # ì˜ˆì‹œ: ê²½ë ¥ ì‚¬í•­ì„ ì²­í‚¹
    if 'experiences' in structured_data:
        for exp in structured_data['experiences']:
            exp_text = f"íšŒì‚¬: {exp.get('company_name', '')}\nì§ë¬´: {exp.get('position', '')}\nê¸°ê°„: {exp.get('period', '')}\në‚´ìš©: {exp.get('description', '')}"
            chunks.extend(text_splitter.split_text(exp_text))
    
    # ì˜ˆì‹œ: ìê¸°ì†Œê°œì„œë¥¼ ì²­í‚¹
    if 'self_introduction' in structured_data:
        chunks.extend(text_splitter.split_text(structured_data['self_introduction']))

    # ... ë‹¤ë¥¸ ì„¹ì…˜ë“¤ë„ ìœ ì‚¬í•˜ê²Œ ì²˜ë¦¬ ...
    return chunks

# ì‚¬ìš© ì˜ˆì‹œ
# chunks = chunk_resume(resume.structured_data)
```

### 2.2 â‘¡ ë²¡í„° ë³€í™˜ (Embedding)

ë¶„í• ëœ í…ìŠ¤íŠ¸ ì²­í¬ë“¤ì€ HuggingFaceì˜ `nlpai-lab/KURE-v1` ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ **1024ì°¨ì›ì˜ ìˆ«ì ë¦¬ìŠ¤íŠ¸(ë²¡í„°)**ë¡œ ë³€í™˜ë©ë‹ˆë‹¤. ì´ ëª¨ë¸ì€ í•œêµ­ì–´ ë¬¸ë§¥ ì´í•´ì— ìµœì í™”ë˜ì–´ ìˆì–´, ë‹¨ìˆœ í‚¤ì›Œë“œ ë§¤ì¹­ì„ ë„˜ì–´ ì˜ë¯¸ë¡ ì  ìœ ì‚¬ì„±ì„ í¬ì°©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
# ai-worker/tasks/embedding.py (ì¼ë¶€)
from langchain_community.embeddings import HuggingFaceEmbeddings
import torch

EMBEDDING_MODEL_NAME = "nlpai-lab/KURE-v1"
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

_embedder = HuggingFaceEmbeddings(
    model_name=EMBEDDING_MODEL_NAME,
    model_kwargs={'device': DEVICE},
    encode_kwargs={'normalize_embeddings': True} # ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ê³„ì‚°ì„ ìœ„í•´ ì •ê·œí™”
)

def embed_chunks(chunks: List[str]) -> List[Dict]:
    """
    í…ìŠ¤íŠ¸ ì²­í¬ ë¦¬ìŠ¤íŠ¸ë¥¼ ì„ë² ë”© ë²¡í„°ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    ê° ì„ë² ë”©ì€ ì›ë³¸ í…ìŠ¤íŠ¸ì™€ ë©”íƒ€ë°ì´í„°ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.
    """
    embedded_data = []
    for i, chunk in enumerate(chunks):
        vector = _embedder.embed_query(chunk)
        embedded_data.append({
            "text": chunk,
            "vector": vector,
            "metadata": {"chunk_index": i} # ì¶”ê°€ ë©”íƒ€ë°ì´í„°
        })
    return embedded_data

# ì‚¬ìš© ì˜ˆì‹œ
# embedded_data = embed_chunks(chunks)
```

### 2.3 â‘¢ DB ì˜êµ¬ ì €ì¥ (Storing)

LangChainì˜ `PGVector` í´ë˜ìŠ¤ë¥¼ í™œìš©í•˜ì—¬ ì„ë² ë”©ëœ ë°ì´í„°ë¥¼ PostgreSQLì˜ `langchain_pg_embedding` í…Œì´ë¸”ì— ì €ì¥í•©ë‹ˆë‹¤. ì´ë•Œ `resume_id`ì™€ ê°™ì€ ì¤‘ìš”í•œ ë©”íƒ€ë°ì´í„°ë¥¼ í•¨ê»˜ ì €ì¥í•˜ì—¬, ë‚˜ì¤‘ì— íŠ¹ì • ì§€ì›ìì˜ ì´ë ¥ì„œ ë°ì´í„°ë§Œ íš¨ìœ¨ì ìœ¼ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í•©ë‹ˆë‹¤.

```python
# ai-worker/tasks/pgvector_store.py (ì¼ë¶€)
from langchain_community.vectorstores.pgvector import PGVector
from langchain_core.documents import Document
from typing import List, Dict
import os

# PostgreSQL ì—°ê²° ì •ë³´ (í™˜ê²½ ë³€ìˆ˜ì—ì„œ ë¡œë“œ)
CONNECTION_STRING = os.getenv("PGVECTOR_CONNECTION_STRING", "postgresql+psycopg2://user:password@host:port/database")
COLLECTION_NAME = "resume_all_embeddings"

def store_embeddings(embedded_data: List[Dict], resume_id: int):
    """
    ì„ë² ë”©ëœ ë°ì´í„°ë¥¼ PGVectorì— ì €ì¥í•©ë‹ˆë‹¤.
    """
    documents = []
    for item in embedded_data:
        # LangChain Document ê°ì²´ë¡œ ë³€í™˜
        # ë©”íƒ€ë°ì´í„°ì— resume_idë¥¼ í¬í•¨í•˜ì—¬ í•„í„°ë§ ê°€ëŠ¥í•˜ê²Œ í•¨
        doc = Document(
            page_content=item["text"],
            metadata={"resume_id": resume_id, **item["metadata"]}
        )
        documents.append(doc)

    # PGVector ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ë°ì´í„° ì €ì¥
    # embedding_functionì€ PGVector ë‚´ë¶€ì—ì„œ ì„ë² ë”©ì„ ìˆ˜í–‰í•  ë•Œ ì‚¬ìš©ë˜ì§€ë§Œ,
    # ì—¬ê¸°ì„œëŠ” ì´ë¯¸ ì„ë² ë”©ëœ ë²¡í„°ë¥¼ ì§ì ‘ ì „ë‹¬í•  ê²ƒì´ë¯€ë¡œ,
    # from_documents ëŒ€ì‹  add_documentsë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜,
    # from_documentsê°€ ë‚´ë¶€ì ìœ¼ë¡œ ì„ë² ë”©ì„ ë‹¤ì‹œ ìˆ˜í–‰í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.
    # LangChainì˜ PGVectorëŠ” from_documents ì‹œ embedding_functionì„ ì‚¬ìš©í•˜ì—¬ ì„ë² ë”©ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    # ë”°ë¼ì„œ, ì´ë¯¸ ì„ë² ë”©ëœ ë²¡í„°ë¥¼ ì €ì¥í•˜ë ¤ë©´, PGVectorì˜ add_vectors ë©”ì„œë“œë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” íš¨ìœ¨ì ì…ë‹ˆë‹¤.

    # PGVector ì¸ìŠ¤í„´ìŠ¤ ì´ˆê¸°í™” (ì„ë² ë”© í•¨ìˆ˜ í•„ìš”)
    vector_store = PGVector(
        connection_string=CONNECTION_STRING,
        embedding_function=_embedder, # ìœ„ì—ì„œ ì •ì˜í•œ _embedder ì‚¬ìš©
        collection_name=COLLECTION_NAME,
        pre_delete_collection=False # ê¸°ì¡´ ì»¬ë ‰ì…˜ ì‚­ì œ ë°©ì§€
    )

    # Document ê°ì²´ ë¦¬ìŠ¤íŠ¸ì™€ í•´ë‹¹ ë©”íƒ€ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì €ì¥
    # from_documentsëŠ” ë‚´ë¶€ì ìœ¼ë¡œ _embedderë¥¼ ì‚¬ìš©í•˜ì—¬ ì„ë² ë”©ì„ ë‹¤ì‹œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
    # ë§Œì•½ ì´ë¯¸ ì„ë² ë”©ëœ ë²¡í„°ë¥¼ ì§ì ‘ ì €ì¥í•˜ê³  ì‹¶ë‹¤ë©´, PGVectorì˜ add_vectors ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
    # ì—¬ê¸°ì„œëŠ” í¸ì˜ìƒ from_documentsë¥¼ ì‚¬ìš©í•˜ë˜, ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì¤‘ë³µ ì„ë² ë”©ì„ í”¼í•˜ëŠ” ë°©ë²•ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.
    vector_store.add_documents(documents)
    print(f"Successfully stored {len(documents)} embeddings for resume_id: {resume_id}")

# ì‚¬ìš© ì˜ˆì‹œ
# store_embeddings(embedded_data, resume.id)
```

---

## ğŸ” 3. ë°ì´í„° ê²€ìƒ‰ ë° í™œìš© (Retrieval: RAG)

AI ë©´ì ‘ê´€ì´ ì§ˆë¬¸ì„ ë˜ì§€ê¸° ì§ì „, ì§€ì›ìì˜ ì´ë ¥ì„œì—ì„œ ì§ˆë¬¸ê³¼ ê°€ì¥ ê´€ë ¨ ê¹Šì€ ë‚´ìš©ì„ ë¹›ì˜ ì†ë„ë¡œ ì°¾ì•„ì™€ LLMì— ì£¼ì…í•˜ì—¬ ì •êµí•œ ê¼¬ë¦¬ ì§ˆë¬¸ì„ ìƒì„±í•©ë‹ˆë‹¤.

### 3.1 â‘  ê´€ë ¨ ë¬¸ë§¥ ê²€ìƒ‰ (Similarity Search)

ì‚¬ìš©ìì˜ ì§ˆë¬¸(Query)ì„ ì„ë² ë”©í•œ í›„, ë²¡í„° ê³µê°„ì—ì„œ ì´ ì§ˆë¬¸ ë²¡í„°ì™€ ê°€ì¥ ê°€ê¹Œìš´ ê±°ë¦¬ì— ìˆëŠ” ì´ë ¥ì„œ ì²­í¬ë“¤ì„ ì°¾ì•„ëƒ…ë‹ˆë‹¤. `pgvector`ëŠ” L2 distance, Cosine similarity, Inner product ë“± ë‹¤ì–‘í•œ ìœ ì‚¬ë„ ì¸¡ì • ë°©ì‹ì„ ì§€ì›í•˜ë©°, ì—¬ê¸°ì„œëŠ” ì½”ì‚¬ì¸ ìœ ì‚¬ë„(ì •ê·œí™”ëœ L2 distance)ë¥¼ í™œìš©í•©ë‹ˆë‹¤. `resume_id` í•„í„°ë§ì„ í†µí•´ ë‹¤ë¥¸ ì§€ì›ìì˜ ë°ì´í„°ê°€ ì„ì´ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.

```python
# ai-worker/tasks/rag_retrieval.py (ì¼ë¶€)
from langchain_community.vectorstores.pgvector import PGVector
from langchain_community.embeddings import HuggingFaceEmbeddings
import os
import torch

CONNECTION_STRING = os.getenv("PGVECTOR_CONNECTION_STRING", "postgresql+psycopg2://user:password@host:port/database")
COLLECTION_NAME = "resume_all_embeddings"
EMBEDDING_MODEL_NAME = "nlpai-lab/KURE-v1"
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

# ì„ë² ë” ì¸ìŠ¤í„´ìŠ¤ ì¬ì‚¬ìš©
_retrieval_embedder = HuggingFaceEmbeddings(
    model_name=EMBEDDING_MODEL_NAME,
    model_kwargs={'device': DEVICE},
    encode_kwargs={'normalize_embeddings': True}
)

def retrieve_context(query: str, resume_id: int, top_k: int = 3) -> List[Dict]:
    """
    ì£¼ì–´ì§„ ì¿¼ë¦¬ì™€ resume_idì— ê¸°ë°˜í•˜ì—¬ ê´€ë ¨ ì´ë ¥ì„œ ë¬¸ë§¥ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.
    """
    vector_store = PGVector(
        connection_string=CONNECTION_STRING,
        embedding_function=_retrieval_embedder,
        collection_name=COLLECTION_NAME
    )

    # í•„í„°: ë‹¤ë¥¸ ì§€ì›ìì˜ ë°ì´í„°ê°€ ì„ì´ì§€ ì•Šë„ë¡ resume_idë¡œ í•„í„°ë§
    search_filter = {"resume_id": resume_id}

    # ìœ ì‚¬ë„ ê²€ìƒ‰ ìˆ˜í–‰ (ê¸°ë³¸ì ìœ¼ë¡œ ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ê¸°ë°˜)
    # similarity_search_with_scoreëŠ” Document ê°ì²´ì™€ ìœ ì‚¬ë„ ì ìˆ˜ë¥¼ ë°˜í™˜
    docs_with_scores = vector_store.similarity_search_with_score(
        query, k=top_k, filter=search_filter
    )

    results = []
    for doc, score in docs_with_scores:
        results.append({
            "text": doc.page_content,
            "metadata": doc.metadata,
            "score": score
        })
    return results

# ì‚¬ìš© ì˜ˆì‹œ
# rag_results = retrieve_context("í”„ë¡œì íŠ¸ ê²½í—˜ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•´ì£¼ì„¸ìš”.", resume_id=1, top_k=3)
```

### 3.2 â‘¡ LLM ê²°í•© (Context Injection)

ê²€ìƒ‰ëœ ì´ë ¥ì„œ ë¬¸ë§¥(Context)ì€ AI(EXAONE)ì˜ í”„ë¡¬í”„íŠ¸ì— ì£¼ì…ë˜ì–´, ì´ë ¥ì„œ ë‚´ìš©ì— ê·¼ê±°í•œ êµ¬ì²´ì ì´ê³  ê°œì¸í™”ëœ ê¼¬ë¦¬ ì§ˆë¬¸ì„ ìƒì„±í•˜ëŠ” ë° í™œìš©ë©ë‹ˆë‹¤. ì´ëŠ” LLMì´ ì¼ë°˜ì ì¸ ì§ˆë¬¸ì´ ì•„ë‹Œ, ì§€ì›ì ë§ì¶¤í˜• ì§ˆë¬¸ì„ í•  ìˆ˜ ìˆë„ë¡ ë•ëŠ” í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

```python
# ai-worker/tasks/question_generator.py (ì¼ë¶€)
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_community.llms import EXAONE # ê°€ìƒì˜ EXAONE LLM í´ë¼ì´ì–¸íŠ¸

# LLM í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (ì‹¤ì œ EXAONE API ì—°ë™ ì½”ë“œ í•„ìš”)
llm = EXAONE(api_key=os.getenv("EXAONE_API_KEY"))

def generate_question_with_rag(query: str, interview_data: Dict) -> str:
    """
    RAGë¥¼ í†µí•´ ê²€ìƒ‰ëœ ë¬¸ë§¥ì„ í™œìš©í•˜ì—¬ LLMìœ¼ë¡œ ì§ˆë¬¸ì„ ìƒì„±í•©ë‹ˆë‹¤.
    """
    # 1. ê´€ë ¨ ì •ë³´ ê²€ìƒ‰
    rag_results = retrieve_context(query, resume_id=interview_data['resume_id'], top_k=3)
    context_text = "\n".join([r['text'] for r in rag_results])

    # 2. í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì •ì˜
    prompt_template = ChatPromptTemplate.from_messages(
        [
            ("system", "ë‹¹ì‹ ì€ AI ë©´ì ‘ê´€ì…ë‹ˆë‹¤. ì§€ì›ìì˜ ì´ë ¥ì„œ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì‹¬ì¸µì ì¸ ì§ˆë¬¸ì„ í•´ì£¼ì„¸ìš”."),
            ("human", """
            ë‹¤ìŒ ì´ë ¥ì„œ ë‚´ìš©ì„ ì°¸ê³ í•˜ì—¬, ì§€ì›ìì—ê²Œ {stage_name} ë‹¨ê³„ì— ì í•©í•œ ì§ˆë¬¸ì„ 1ê°œ ìƒì„±í•´ì£¼ì„¸ìš”.
            ì´ë ¥ì„œ ë‚´ìš©:
            ---
            {context}
            ---
            í˜„ì¬ ì§ˆë¬¸ ì£¼ì œ: {query}
            ìƒì„±í•  ì§ˆë¬¸:
            """)
        ]
    )

    # 3. LLM ì²´ì¸ êµ¬ì„±
    chain = prompt_template | llm | StrOutputParser()

    # 4. í”„ë¡¬í”„íŠ¸ì— ì£¼ì…í•˜ì—¬ ì§ˆë¬¸ ìƒì„±
    final_question = chain.invoke({
        "context": context_text, # <--- ì—¬ê¸°ê°€ ë²¡í„° DBê°€ ì¤€ ì„ ë¬¼!
        "stage_name": interview_data['current_stage_display_name'],
        "query": query # í˜„ì¬ ì§ˆë¬¸ì˜ ì˜ë„
    })
    return final_question

# ì‚¬ìš© ì˜ˆì‹œ
# interview_info = {"resume_id": 1, "current_stage_display_name": "ê¸°ìˆ  ë©´ì ‘"}
# question = generate_question_with_rag("í”„ë¡œì íŠ¸ ê²½í—˜ì— ëŒ€í•´ ìì„¸íˆ ì„¤ëª…í•´ì£¼ì„¸ìš”.", interview_info)
# print(question)
```

---

## ğŸ’¡ 4. ì„±ëŠ¥ ìµœì í™” (Performance Optimization)

ëŒ€ê·œëª¨ ë²¡í„° ë°ì´í„°ì…‹ì—ì„œ íš¨ìœ¨ì ì¸ ê²€ìƒ‰ ì„±ëŠ¥ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ `pgvector`ì˜ ì¸ë±ì‹± ê¸°ëŠ¥ì„ ì ê·¹ í™œìš©í•´ì•¼ í•©ë‹ˆë‹¤.

### 4.1 ì¸ë±ì‹± ì „ëµ: IVFFlat

`pgvector`ëŠ” `IVFFlat` ì¸ë±ìŠ¤ë¥¼ ì§€ì›í•˜ì—¬ ëŒ€ê·œëª¨ ë°ì´í„°ì…‹ì—ì„œ ìœ ì‚¬ë„ ê²€ìƒ‰ ì†ë„ë¥¼ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. `IVFFlat` ì¸ë±ìŠ¤ëŠ” ë²¡í„° ê³µê°„ì„ ì—¬ëŸ¬ í´ëŸ¬ìŠ¤í„°ë¡œ ë¶„í• í•˜ì—¬ ê²€ìƒ‰ ë²”ìœ„ë¥¼ ì¤„ì´ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.

```sql
-- IVFFlat ì¸ë±ìŠ¤ ìƒì„± ì˜ˆì‹œ
-- num_listsëŠ” í´ëŸ¬ìŠ¤í„°ì˜ ê°œìˆ˜ë¥¼ ì˜ë¯¸í•˜ë©°, ì¼ë°˜ì ìœ¼ë¡œ total_rows / 1000 ì •ë„ê°€ ê¶Œì¥ë©ë‹ˆë‹¤.
-- 100ë§Œ ê°œì˜ ë²¡í„°ê°€ ìˆë‹¤ë©´ num_listsëŠ” 1000 ì •ë„ê°€ ì ë‹¹í•©ë‹ˆë‹¤.
CREATE INDEX ON langchain_pg_embedding USING ivfflat (embedding vector_cosine_ops) WITH (lists = 1000);

-- ì¸ë±ìŠ¤ ìƒì„± í›„, ê²€ìƒ‰ ì‹œ `ivfflat.probes` ê°’ì„ ì¡°ì •í•˜ì—¬ ê²€ìƒ‰ ì†ë„ì™€ ì •í™•ë„ ê°„ì˜ ê· í˜•ì„ ë§ì¶œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
-- SET ivfflat.probes = 10; -- ê¸°ë³¸ê°’ì€ 1
```
*   **`lists`**: í´ëŸ¬ìŠ¤í„°ì˜ ê°œìˆ˜. ë°ì´í„°ì…‹ í¬ê¸°ì— ë¹„ë¡€í•˜ì—¬ ì„¤ì •í•˜ë©°, ë„ˆë¬´ ì‘ìœ¼ë©´ ê²€ìƒ‰ ì •í™•ë„ê°€ ë–¨ì–´ì§€ê³ , ë„ˆë¬´ í¬ë©´ ì¸ë±ìŠ¤ ìƒì„± ë° ê²€ìƒ‰ ì†ë„ê°€ ëŠë ¤ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*   **`probes`**: ê²€ìƒ‰ ì‹œ íƒìƒ‰í•  í´ëŸ¬ìŠ¤í„°ì˜ ê°œìˆ˜. `probes` ê°’ì„ ë†’ì´ë©´ ì •í™•ë„ëŠ” ì˜¬ë¼ê°€ì§€ë§Œ ê²€ìƒ‰ ì†ë„ëŠ” ëŠë ¤ì§‘ë‹ˆë‹¤.

### 4.2 ë°°ì¹˜ ì²˜ë¦¬ (Batch Processing)

ëŒ€ëŸ‰ì˜ ë°ì´í„°ë¥¼ ì„ë² ë”©í•˜ê³  ì €ì¥í•  ë•ŒëŠ” ê°œë³„ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸°ë³´ë‹¤ ë°°ì¹˜(Batch) ë‹¨ìœ„ë¡œ ë¬¶ì–´ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ë„¤íŠ¸ì›Œí¬ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê³  íš¨ìœ¨ì„±ì„ ë†’ì…ë‹ˆë‹¤. Celeryì™€ ê°™ì€ ë¶„ì‚° íë¥¼ í™œìš©í•˜ì—¬ ì´ ì‘ì—…ì„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤.

### 4.3 í•˜ë“œì›¨ì–´ ê³ ë ¤ì‚¬í•­

*   **CPU/GPU**: ì„ë² ë”© ëª¨ë¸ ì¶”ë¡ ì€ GPUë¥¼ í™œìš©í•  ë•Œ í›¨ì”¬ ë¹ ë¦…ë‹ˆë‹¤. Celery ì›Œì»¤ë¥¼ GPUê°€ ì¥ì°©ëœ ì„œë²„ì— ë°°í¬í•˜ì—¬ ì„ë² ë”© ì‘ì—…ì„ ê°€ì†í™”í•©ë‹ˆë‹¤.
*   **ë©”ëª¨ë¦¬**: ë²¡í„° ë°ì´í„°ëŠ” ë©”ëª¨ë¦¬ë¥¼ ë§ì´ ì‚¬ìš©í•˜ë¯€ë¡œ, PostgreSQL ì„œë²„ì˜ ì¶©ë¶„í•œ RAM í™•ë³´ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. `shared_buffers`, `work_mem` ë“±ì˜ PostgreSQL ì„¤ì •ì„ ìµœì í™”í•©ë‹ˆë‹¤.
*   **ë””ìŠ¤í¬ I/O**: ëŒ€ê·œëª¨ ì¸ë±ìŠ¤ ë° ë°ì´í„° ì €ì¥ì„ ìœ„í•´ ë¹ ë¥¸ ë””ìŠ¤í¬(SSD/NVMe) ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.

---

## ğŸ”’ 5. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­ (Security Considerations)

ë¯¼ê°í•œ ê°œì¸ ì •ë³´ë¥¼ ë‹¤ë£¨ëŠ” ë§Œí¼, ë²¡í„° DB ì‹œìŠ¤í…œì˜ ë³´ì•ˆì€ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤.

### 5.1 ë°ì´í„° ê²©ë¦¬ ë° ì ‘ê·¼ ì œì–´

*   **`resume_id` í•„í„°ë§**: ëª¨ë“  ê²€ìƒ‰ ì¿¼ë¦¬ì— `resume_id` í•„í„°ë¥¼ ê°•ì œ ì ìš©í•˜ì—¬, íŠ¹ì • ì§€ì›ìì˜ ë°ì´í„°ê°€ ë‹¤ë¥¸ ì§€ì›ìì—ê²Œ ë…¸ì¶œë˜ê±°ë‚˜ ê²€ìƒ‰ë˜ëŠ” ê²ƒì„ ì›ì²œì ìœ¼ë¡œ ì°¨ë‹¨í•©ë‹ˆë‹¤. ì´ëŠ” ë‹¤ì¤‘ í…Œë„ŒíŠ¸ í™˜ê²½ì—ì„œ í•„ìˆ˜ì ì¸ ë³´ì•ˆ ì¡°ì¹˜ì…ë‹ˆë‹¤.
*   **DB ì‚¬ìš©ì ê¶Œí•œ**: PostgreSQL ì‚¬ìš©ìì—ê²Œ ìµœì†Œí•œì˜ í•„ìš”í•œ ê¶Œí•œë§Œ ë¶€ì—¬í•©ë‹ˆë‹¤. `SELECT`, `INSERT` ë“± í•„ìš”í•œ ì‘ì—…ì—ë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ ì œí•œí•©ë‹ˆë‹¤.
*   **ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ**: PostgreSQL ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ ì ‘ê·¼ì€ ë‚´ë¶€ ë„¤íŠ¸ì›Œí¬ ë˜ëŠ” VPNì„ í†µí•´ì„œë§Œ í—ˆìš©í•˜ê³ , ì™¸ë¶€ì—ì„œì˜ ì§ì ‘ ì ‘ê·¼ì„ ì°¨ë‹¨í•©ë‹ˆë‹¤.

### 5.2 ë°ì´í„° ì•”í˜¸í™”

*   **ì „ì†¡ ì¤‘ ì•”í˜¸í™” (Encryption in Transit)**: PostgreSQLê³¼ì˜ ëª¨ë“  í†µì‹ ì€ SSL/TLSë¥¼ ì‚¬ìš©í•˜ì—¬ ì•”í˜¸í™”í•©ë‹ˆë‹¤.
*   **ì €ì¥ ë°ì´í„° ì•”í˜¸í™” (Encryption at Rest)**: ë°ì´í„°ë² ì´ìŠ¤ ì„œë²„ì˜ ë””ìŠ¤í¬ ì•”í˜¸í™” ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬ ì €ì¥ëœ ë°ì´í„°ë¥¼ ë³´í˜¸í•©ë‹ˆë‹¤. `pgvector` ìì²´ëŠ” ë²¡í„° ë°ì´í„°ë¥¼ ì•”í˜¸í™”í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ, OS/íŒŒì¼ ì‹œìŠ¤í…œ ë ˆë²¨ì˜ ì•”í˜¸í™”ê°€ í•„ìš”í•©ë‹ˆë‹¤.

### 5.3 ë¯¼ê° ì •ë³´ ì²˜ë¦¬

*   **ë¹„ì‹ë³„í™”/ë§ˆìŠ¤í‚¹**: ì´ë ¥ì„œ ì›ë³¸ì—ì„œ ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸, ì£¼ì†Œ ë“± ë¯¼ê°í•œ ê°œì¸ ì‹ë³„ ì •ë³´ë¥¼ ì„ë² ë”© ì „ì— ë¹„ì‹ë³„í™”í•˜ê±°ë‚˜ ë§ˆìŠ¤í‚¹ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•©ë‹ˆë‹¤. ì„ë² ë”©ëœ ë²¡í„° ìì²´ëŠ” ì›ë³¸ í…ìŠ¤íŠ¸ë¥¼ ë³µì›í•˜ê¸° ì–´ë µì§€ë§Œ, ë³´ì•ˆ ì‹¬ì¸µ ë°©ì–´ë¥¼ ìœ„í•´ ì¤‘ìš”í•©ë‹ˆë‹¤.

---

## ğŸ“ˆ 6. ëª¨ë‹ˆí„°ë§ ë° ìœ ì§€ë³´ìˆ˜ (Monitoring & Maintenance)

ì•ˆì •ì ì¸ ì„œë¹„ìŠ¤ ìš´ì˜ì„ ìœ„í•´ ë²¡í„° DB ì‹œìŠ¤í…œì— ëŒ€í•œ ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ê³¼ ìœ ì§€ë³´ìˆ˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.

### 6.1 ë²¡í„° DB ìƒíƒœ ëª¨ë‹ˆí„°ë§

*   **PostgreSQL ì§€í‘œ**: CPU ì‚¬ìš©ëŸ‰, ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰, ë””ìŠ¤í¬ I/O, ì—°ê²° ìˆ˜, ì¿¼ë¦¬ ì§€ì—° ì‹œê°„ ë“±ì„ ëª¨ë‹ˆí„°ë§í•©ë‹ˆë‹¤.
*   **`pgvector` íŠ¹ì • ì§€í‘œ**: ì¸ë±ìŠ¤ í¬ê¸°, ì¸ë±ìŠ¤ ì‚¬ìš©ë¥ , `ivfflat` ì¸ë±ìŠ¤ì˜ `lists` ë° `probes` ì„¤ì •ì— ë”°ë¥¸ ê²€ìƒ‰ ì„±ëŠ¥ ë³€í™” ë“±ì„ ì£¼ê¸°ì ìœ¼ë¡œ í™•ì¸í•©ë‹ˆë‹¤.
*   **ì˜¤ë¥˜ ë¡œê¹…**: ì„ë² ë”© ì‹¤íŒ¨, DB ì—°ê²° ì˜¤ë¥˜ ë“± ì‹œìŠ¤í…œì—ì„œ ë°œìƒí•˜ëŠ” ëª¨ë“  ì˜¤ë¥˜ë¥¼ ë¡œê¹…í•˜ê³  ì•Œë¦¼ ì‹œìŠ¤í…œê³¼ ì—°ë™í•©ë‹ˆë‹¤.

### 6.2 ì¬ì„ë² ë”© ë° ì¸ë±ìŠ¤ ì¬êµ¬ì¶• ì „ëµ

*   **ëª¨ë¸ ì—…ë°ì´íŠ¸**: ë” ë‚˜ì€ ì„ë² ë”© ëª¨ë¸ì´ ì¶œì‹œë˜ê±°ë‚˜, ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •(Fine-tuning)í•œ ê²½ìš°, ê¸°ì¡´ ë²¡í„° ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ ëª¨ë¸ë¡œ ì¬ì„ë² ë”©í•˜ê³  ì¸ë±ìŠ¤ë¥¼ ì¬êµ¬ì¶•í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ì—†ì´ ì ì§„ì ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ì „ëµì„ ë§ˆë ¨í•´ì•¼ í•©ë‹ˆë‹¤.
*   **ë°ì´í„° ë³€í™”**: ì´ë ¥ì„œ ë°ì´í„°ì˜ íŠ¹ì„±ì´ í¬ê²Œ ë³€í•˜ê±°ë‚˜, ì²­í‚¹ ì „ëµì´ ë³€ê²½ë  ê²½ìš°ì—ë„ ì¬ì„ë² ë”© ë° ì¸ë±ìŠ¤ ì¬êµ¬ì¶•ì„ ê³ ë ¤í•©ë‹ˆë‹¤.
*   **ì¸ë±ìŠ¤ ìµœì í™”**: ë°ì´í„°ê°€ ì§€ì†ì ìœ¼ë¡œ ì¶”ê°€ë¨ì— ë”°ë¼ `IVFFlat` ì¸ë±ìŠ¤ì˜ `lists` íŒŒë¼ë¯¸í„°ê°€ ìµœì ì˜ ìƒíƒœë¥¼ ìœ ì§€í•˜ì§€ ëª»í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì£¼ê¸°ì ìœ¼ë¡œ ì¸ë±ìŠ¤ ì„±ëŠ¥ì„ ë¶„ì„í•˜ê³  í•„ìš”ì‹œ ì¬êµ¬ì¶•í•˜ì—¬ ìµœì ì˜ ê²€ìƒ‰ íš¨ìœ¨ì„ ìœ ì§€í•©ë‹ˆë‹¤.

---

## ğŸ¯ 7. ê²°ë¡  ë° í–¥í›„ ê³¼ì œ (Conclusion & Future Work)

ìš°ë¦¬ í”„ë¡œì íŠ¸ì˜ ë²¡í„° DB ì‹œìŠ¤í…œì€ ì§€ì›ìì˜ ì´ë ¥ì„œë¥¼ **ìˆ˜í•™ì ì¸ ì§€ë„ë¡œ ë³€í™˜(Embedding)**í•˜ì—¬ ì €ì¥í•˜ê³ , ë©´ì ‘ ê´€ë¦¬ê°€ í•„ìš”í•œ ì‹œì ì— **ê°€ì¥ ê´€ë ¨ ìˆëŠ” ì¦ê±°(Context)ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì°¾ì•„ë‚´ì–´(Retrieval)** AI ë©´ì ‘ê´€ì—ê²Œ ì „ë‹¬í•˜ëŠ” **'ìŠ¤ë§ˆíŠ¸í•œ ìë£Œì‹¤'** ì—­í• ì„ ì„±ê³µì ìœ¼ë¡œ ìˆ˜í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤.

**í•µì‹¬ ê°•ì :**
*   **ë¹„ìš© íš¨ìœ¨ì„±**: ê¸°ì¡´ PostgreSQL ì¸í”„ë¼ë¥¼ í™œìš©í•˜ì—¬ ì¶”ê°€ ë¹„ìš© ì—†ì´ ë²¡í„° ê²€ìƒ‰ ê¸°ëŠ¥ì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.
*   **ì •í™•ì„±**: `KURE-v1` ëª¨ë¸ê³¼ `pgvector`ì˜ ìœ ì‚¬ë„ ê²€ìƒ‰ì„ í†µí•´ ë¬¸ë§¥ì  ì˜ë¯¸ë¥¼ ì •í™•íˆ íŒŒì•…í•˜ì—¬ ê´€ë ¨ì„± ë†’ì€ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
*   **ë³´ì•ˆì„±**: `resume_id` ê¸°ë°˜ì˜ ê°•ë ¥í•œ í•„í„°ë§ìœ¼ë¡œ ë°ì´í„° ìœ ì¶œ ê°€ëŠ¥ì„±ì„ ì›ì²œ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤.

**í–¥í›„ ê³¼ì œ:**
*   **í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰**: í‚¤ì›Œë“œ ê²€ìƒ‰ê³¼ ë²¡í„° ê²€ìƒ‰ì„ ê²°í•©í•œ í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰(Hybrid Search) ë„ì…ì„ í†µí•´ ê²€ìƒ‰ ì •í™•ë„ì™€ ì¬í˜„ìœ¨ì„ ë”ìš± ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*   **ë™ì  ì²­í‚¹**: ì´ë ¥ì„œ ë‚´ìš©ì˜ íŠ¹ì„±ì— ë”°ë¼ ì²­í¬ í¬ê¸°ë‚˜ ë¶„í•  ì „ëµì„ ë™ì ìœ¼ë¡œ ì¡°ì ˆí•˜ëŠ” ì—°êµ¬ë¥¼ í†µí•´ ì„ë² ë”© í’ˆì§ˆì„ ê°œì„ í•©ë‹ˆë‹¤.
*   **ë²¡í„° ì••ì¶•**: ëŒ€ê·œëª¨ ë²¡í„° ë°ì´í„°ì…‹ì˜ ì €ì¥ ê³µê°„ ë° ê²€ìƒ‰ ì†ë„ ìµœì í™”ë¥¼ ìœ„í•´ ë²¡í„° ì••ì¶• ê¸°ìˆ (ì˜ˆ: Product Quantization) ë„ì…ì„ ê²€í† í•©ë‹ˆë‹¤.

ì´ ê°€ì´ë“œê°€ ë²¡í„° DBë¥¼ í™œìš©í•œ RAG ì‹œìŠ¤í…œ êµ¬ì¶• ë° ìš´ì˜ì— ëŒ€í•œ ê¹Šì´ ìˆëŠ” ì´í•´ë¥¼ ë•ê³ , í”„ë¡œì íŠ¸ì˜ ì„±ê³µì ì¸ ë°œì „ì— ê¸°ì—¬í•˜ê¸°ë¥¼ ë°”ëë‹ˆë‹¤.
# PostgreSQL + pgvector ê¸°ë°˜ ë²¡í„° ì €ì¥ì†Œ ì•„í‚¤í…ì²˜ ì„¤ê³„

## 1. ê°œìš”

ë³¸ í”„ë¡œì íŠ¸ëŠ” ë¹„ìš© íš¨ìœ¨ì„±ê³¼ ë°ì´í„° ì •í•©ì„±ì„ ìµœìš°ì„  ì„¤ê³„ ì›ì¹™ìœ¼ë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ì— ë”°ë¼ ë³„ë„ì˜ ìœ ë£Œ ì „ìš© ë²¡í„° ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ë„ì…í•˜ëŠ” ëŒ€ì‹ , ê¸°ì¡´ ê´€ê³„í˜• ë°ì´í„°ë² ì´ìŠ¤ í™˜ê²½ì„ í™•ì¥í•˜ëŠ” ë°©ì‹ì„ ì±„íƒí•˜ì˜€ìŠµë‹ˆë‹¤.

í•µì‹¬ ë²¡í„° ì €ì¥ì†Œë¡œëŠ” PostgreSQLê³¼ pgvector ì¡°í•©ì„ í™œìš©í•˜ì˜€ìŠµë‹ˆë‹¤.

## 2. ê¸°ìˆ  êµ¬ì„± ìš”ì†Œ

### 2.1 PostgreSQL

PostgreSQLì€ ì˜¤í”ˆì†ŒìŠ¤ ê¸°ë°˜ì˜ ê´€ê³„í˜• ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ ì‹œìŠ¤í…œ(RDBMS)ì…ë‹ˆë‹¤. ì£¼ìš” íŠ¹ì§•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- ACID íŠ¸ëœì­ì…˜ì„ ë³´ì¥í•©ë‹ˆë‹¤.
- ë†’ì€ ë°ì´í„° ì •í•©ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
- ì•ˆì •ì ì¸ ìš´ì˜ í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤.
- ê¸°ì¡´ ì„œë¹„ìŠ¤ ë°ì´í„°ì™€ì˜ í†µí•©ì´ ìš©ì´í•©ë‹ˆë‹¤.

### 2.2 pgvector

pgvectorëŠ” PostgreSQL í™•ì¥(extension) ëª¨ë“ˆë¡œ, ë²¡í„° ë°ì´í„° ì²˜ë¦¬ë¥¼ ì§€ì›í•©ë‹ˆë‹¤. ì£¼ìš” ê¸°ëŠ¥ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

- ë²¡í„°(vector) ë°ì´í„° íƒ€ì…ì„ ì§€ì›í•©ë‹ˆë‹¤.
- ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ë° L2 ê±°ë¦¬ ê¸°ë°˜ ê²€ìƒ‰ì„ ì§€ì›í•©ë‹ˆë‹¤.
- Approximate Nearest Neighbor(ANN) ì¸ë±ì‹±ì„ ì§€ì›í•©ë‹ˆë‹¤.
- SQL ê¸°ë°˜ ë²¡í„° ìœ ì‚¬ë„ ê²€ìƒ‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì´ë¥¼ í†µí•´ ê´€ê³„í˜• ë°ì´í„°ì™€ ë²¡í„° ì„ë² ë”©ì„ ë™ì¼í•œ í…Œì´ë¸” ë‚´ì—ì„œ í†µí•© ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 3. ì•„í‚¤í…ì²˜ ì„ íƒ ë°°ê²½

### 3.1 ë¹„ìš© íš¨ìœ¨ì„±

ì „ìš© ë²¡í„° ë°ì´í„°ë² ì´ìŠ¤ ì†”ë£¨ì…˜(ì˜ˆ: Pinecone, Weaviate, Milvus)ì€ ê³ ì„±ëŠ¥ ë²¡í„° ê²€ìƒ‰ì„ ì œê³µí•˜ì§€ë§Œ, ë³„ë„ì˜ ì¸í”„ë¼ êµ¬ì¶• ë° ìš´ì˜ ë¹„ìš©ì´ ë°œìƒí•©ë‹ˆë‹¤.

PostgreSQL + pgvector ì¡°í•©ì€ ê¸°ì¡´ DB ì¸í”„ë¼ë¥¼ í™œìš©í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¶”ê°€ ë¹„ìš©ì„ ìµœì†Œí™”í•  ìˆ˜ ìˆìœ¼ë©°, ìš´ì˜ ë³µì¡ë„ ë˜í•œ ë‚®ì¶œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 3.2 ë°ì´í„° ì •í•©ì„± í™•ë³´

ë²¡í„° ë°ì´í„°ì™€ ë©”íƒ€ë°ì´í„°ë¥¼ ë³„ë„ ì‹œìŠ¤í…œì— ë¶„ë¦¬í•˜ì—¬ ì €ì¥í•  ê²½ìš°, íŠ¸ëœì­ì…˜ ë¶ˆì¼ì¹˜ ë° ë°ì´í„° ë™ê¸°í™” ì§€ì—° ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

PostgreSQL í™˜ê²½ ë‚´ì—ì„œ ë²¡í„°ì™€ ì •í˜• ë°ì´í„°ë¥¼ í•¨ê»˜ ê´€ë¦¬í•¨ìœ¼ë¡œì¨ ë‹¨ì¼ íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ë°ì´í„° ì •í•©ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 4. ê¸°ìˆ ì  íŠ¹ì§•

PostgreSQL + pgvector ì•„í‚¤í…ì²˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¥ì ì„ ì œê³µí•©ë‹ˆë‹¤.

1. ê´€ê³„í˜• ë°ì´í„°ì™€ ë²¡í„° ë°ì´í„°ì˜ í†µí•© ê´€ë¦¬ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
2. SQL ê¸°ë°˜ ê²€ìƒ‰ ë¡œì§ êµ¬í˜„ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
3. ê¸°ì¡´ ORM ë° ë°±ì—”ë“œ ì‹œìŠ¤í…œê³¼ì˜ í˜¸í™˜ì„±ì´ ë†’ìŠµë‹ˆë‹¤.
4. ì´ˆê¸° ë‹¨ê³„ í”„ë¡œì íŠ¸ì— ì í•©í•œ ë¹„ìš© êµ¬ì¡°ë¥¼ ê°–ìŠµë‹ˆë‹¤.

## 5. í•œê³„ ë° ê³ ë ¤ì‚¬í•­

ë³¸ êµ¬ì¡°ëŠ” ì¤‘ì†Œ ê·œëª¨ íŠ¸ë˜í”½ ë° ìˆ˜ì‹­ë§Œ~ìˆ˜ë°±ë§Œ ê±´ ìˆ˜ì¤€ì˜ ë²¡í„° ë°ì´í„°ê¹Œì§€ íš¨ìœ¨ì ìœ¼ë¡œ ìš´ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ì—ëŠ” ì „ìš© ë²¡í„° ë°ì´í„°ë² ì´ìŠ¤ ë„ì…ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.

- ì´ˆëŒ€ê·œëª¨ ë²¡í„° ë°ì´í„°ì…‹ ìš´ì˜ì´ í•„ìš”í•œ ê²½ìš°
- ë°€ë¦¬ì´ˆ ë‹¨ìœ„ ì´ˆê³ ì† ê²€ìƒ‰ì´ ìš”êµ¬ë˜ëŠ” ê²½ìš°
- ëŒ€ê·œëª¨ ìˆ˜í‰ í™•ì¥ì´ í•„ìš”í•œ ê²½ìš°
- ê³ ê¸‰ í•„í„°ë§ê³¼ ë²¡í„° ê²€ìƒ‰ì˜ ë³µí•© ì¿¼ë¦¬ ìµœì í™”ê°€ í•„ìš”í•œ ê²½ìš°

ë”°ë¼ì„œ PostgreSQL + pgvectorëŠ” ì „ìš© ë²¡í„° DBë¼ê¸°ë³´ë‹¤ëŠ”, ë²¡í„° ê¸°ëŠ¥ì„ í™•ì¥í•œ ê´€ê³„í˜• ë°ì´í„°ë² ì´ìŠ¤ë¡œ ì´í•´í•˜ëŠ” ê²ƒì´ ë³´ë‹¤ ì •í™•í•©ë‹ˆë‹¤.

## 6. ê²°ë¡ 

ë³¸ í”„ë¡œì íŠ¸ëŠ” ë¹„ìš© íš¨ìœ¨ì„±, ìš´ì˜ ë‹¨ìˆœì„±, ë°ì´í„° ì •í•©ì„±ì„ ì¢…í•©ì ìœ¼ë¡œ ê³ ë ¤í•˜ì—¬ PostgreSQL + pgvector ê¸°ë°˜ ë²¡í„° ì €ì¥ì†Œ ì•„í‚¤í…ì²˜ë¥¼ ì±„íƒí•˜ì˜€ìŠµë‹ˆë‹¤.

ì´ë¥¼ í†µí•´ ê´€ê³„í˜• ë°ì´í„°ë² ì´ìŠ¤ì˜ ì•ˆì •ì„±ê³¼ ë²¡í„° ê²€ìƒ‰ ê¸°ëŠ¥ì„ ë™ì‹œì— í™•ë³´í•˜ëŠ” í†µí•©í˜• êµ¬ì¡°ë¥¼ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤.
