# 📑 PDF 파싱 엔진 기술 분석 및 이력서 구조화 시스템 종합 보고서

---

## 1. 시스템 개요

본 문서는 **pdfplumber 기반 이력서 자동 파싱 시스템**의 기술적 구조와 동작 원리를 설명하는 종합 보고서입니다.

본 시스템은 다음 두 가지를 동시에 수행합니다.

1. PDF 내부 객체(Object) 기반 텍스트·표 추출
2. 추출 데이터를 구조화된 JSON 형태로 변환

핵심 목표는 다음과 같습니다.

* 이력서의 **정형 데이터(학력, 경력, 수상 등)**를 정확히 매핑
* 표 기반 레이아웃을 최대한 보존
* 비정형 자기소개서까지 구조적으로 분리

---

# 2. PDF 파싱 엔진 핵심 원리

## 2-1. 객체 기반 추출 (Object-Based Extraction)

본 시스템은 pdfplumber를 사용합니다.

pdfplumber는 OCR 방식이 아닙니다.

즉,

❌ 이미지를 보고 글자를 추측하지 않음
✅ PDF 내부 객체 데이터 직접 분석

PDF 내부에는 다음 정보가 저장되어 있습니다.

* 문자(Char)

  * x0, x1, top, bottom 좌표
  * 폰트
  * 크기
* 선(Line)
* 사각형(Rect)
* 기타 그래픽 객체

이 정보를 조합하여 문서 구조를 재구성합니다.

---

## 2-2. 좌표 시스템 기반 구조 인식

pdfplumber는 페이지를 하나의 좌표 평면으로 간주합니다.

### 텍스트 문장 인식

* 같은 y축에 일정 간격으로 배열 → 하나의 문장
* x좌표 간격 → 띄어쓰기 판단

### 표(Table) 인식

* 선(Line) 객체 감지
* 선이 교차하는 지점 → 셀(Cell) 생성
* 행(Row), 열(Column) 구성

이 원리 덕분에 이력서처럼 표가 많은 문서에 매우 강력합니다.

---

# 3. 전체 파싱 아키텍처

시스템 흐름은 다음과 같습니다.

```
PDF 입력
   ↓
pdfplumber 객체 추출
   ↓
텍스트 + 표 데이터 분리 수집
   ↓
섹션 상태 전환(State Machine)
   ↓
카테고리별 구조화
   ↓
JSON 출력
```

---

# 4. 코드 상세 분석

아래 코드를 기준으로 매우 상세히 설명합니다.

---

# 4-1. 유틸리티 함수 분석

---

## ① clean_text(text)

### 목적

* 불필요한 공백 제거
* 줄바꿈 통합
* 정규식 매칭 정확도 향상

### 코드 핵심

```python
return re.sub(r'\s+', ' ', text).strip()
```

### 동작 원리

* `\s+` → 하나 이상의 공백
* 모든 공백을 단일 스페이스로 변환
* 앞뒤 공백 제거

### 입력 / 출력 예시

입력:

```
"  홍길동   \n  백엔드   개발자  "
```

출력:

```
"홍길동 백엔드 개발자"
```

---

## ② get_row_text(row)

### 목적

* 표 한 줄을 하나의 문자열로 결합
* 섹션 키워드 탐지용

### 예시

입력:

```
["학력", "", ""]
```

출력:

```
"학력"
```

입력:

```
["2020.03", "서울대학교", "컴퓨터공학과"]
```

출력:

```
"2020.03서울대학교컴퓨터공학과"
```

공백 제거 후 붙입니다.

---

## ③ is_date(text)

### 목적

* 날짜 또는 연도 포함 여부 확인

정규식:

```
\d{4}
```

### 예시

입력:

```
"2023.03 ~ 2024.02"
```

출력:

```
True
```

입력:

```
"컴퓨터공학과"
```

출력:

```
False
```

---

# 4-2. 메인 함수: parse_resume_final()

---

## 1단계: 기본 데이터 구조 생성

```python
data = {
    "header": { "name": "", "target_company": "", "target_role": "" },
    "education": [],
    "activities": [],
    "awards": [],
    "projects": [],
    "certifications": [],
    "self_intro": []
}
```

### 출력 형태 예시

```json
{
  "header": {
    "name": "홍길동",
    "target_company": "삼성전자",
    "target_role": "백엔드 개발"
  },
  "education": [],
  ...
}
```

---

## 2단계: 입력 소스 판별

```python
is_file_path = False
```

조건:

* 문자열이 .pdf로 끝남
* 실제 파일 존재

→ 파일로 판단

아니면 텍스트로 판단

---

## 3단계: PDF에서 데이터 추출

### 텍스트 추출

```python
text = page.extract_text()
```

### 예시 출력

```
이름 : 홍길동
지원직무 : 백엔드 개발
```

---

### 표 추출

```python
tables.extend(page.extract_tables())
```

### 예시 출력 구조

```
[
  [
    ["이름", "홍길동"],
    ["지원직무", "백엔드 개발"]
  ],
  [
    ["학력"],
    ["2020.03~2024.02", "서울대학교", "컴퓨터공학과", "3.8/4.5"]
  ]
]
```

---

# 5. 헤더(Header) 파싱 로직

## 로직 설명

1. "이름" 찾음
2. 오른쪽 칸(i+1) 값 가져옴
3. 없으면 i+2 확인

### 예시 표 입력

```
["이름", "홍길동"]
```

출력:

```json
"header": {
  "name": "홍길동"
}
```

---

## 폴백 로직 (정규식)

표에 이름이 없으면:

```
이\s*름\s*[:：\-\s]+([가-힣]{2,4})
```

입력:

```
이름 : 홍길동
```

출력:

```
홍길동
```

---

# 6. 섹션 상태 관리 (State Machine)

변수:

```python
current_section
```

동작 방식:

| 발견 키워드 | 상태 변경      |
| ----------- | -------------- |
| 학력        | education      |
| 경력/활동   | activities     |
| 수상        | awards         |
| 자격증      | certifications |
| 프로젝트    | projects       |

---

# 7. 학력 파싱 상세 분석

입력 예시:

```
["2020.03~2024.02", "서울대학교-컴퓨터공학과", "3.8/4.5"]
```

### 분해 과정

1. period → 첫 칸
2. 학교명 → parts[0]
3. 전공 → parts[1]
4. 학점 → GPA 패턴 검색

### 출력 예시

```json
{
  "period": "2020.03~2024.02",
  "school_name": "서울대학교",
  "major": "컴퓨터공학과",
  "gpa": "3.8/4.5"
}
```

---

# 8. 활동(Activities) 파싱

입력:

```
["2023.01~2023.06", "AI 프로젝트 - 1등 (2023)", "팀장", "하이브본사"]
```

### 처리 단계

1. 괄호 안 날짜 추출
2. * 기준 분리
3. 역할 보강

출력:

```json
{
  "period": "2023",
  "title": "AI 프로젝트",
  "role": "팀장",
  "organization": "하이브본사"
}
```

---

# 9. 수상(Awards) 파싱

입력:

```
["2023", "AI 경진대회 - 최우수상", "한국정보원"]
```

출력:

```json
{
  "date": "2023",
  "title": "AI 경진대회",
  "organization": "한국정보원"
}
```

---

# 10. 프로젝트 파싱

입력:

```
["2024.01", "RAG 기반 챗봇 개발", "FastAPI"]
```

출력:

```json
{
  "period": "2024.01",
  "title": "RAG 기반 챗봇 개발",
  "organization": "FastAPI"
}
```

---

# 11. 자기소개서(Self Introduction) 분리

정규식:

```
(\[질문\d+\].*?(?:주십시오|세요))
```

### 입력 예시

```
[질문1] 지원 동기를 작성하세요
저는 백엔드 개발자가 되고 싶습니다.

[질문2] 협업 경험을 작성하세요
...
```

### 출력

```json
[
  {
    "question": "[질문1] 지원 동기를 작성하세요",
    "answer": "저는 백엔드 개발자가 되고 싶습니다."
  }
]
```

---

# 12. 라이브러리 비교 분석

| 라이브러리   | 특징                  | 강점                | 한계                     |
| ------------ | --------------------- | ------------------- | ------------------------ |
| pdfplumber   | 객체 기반 고수준 추출 | 표 인식 강력        | 대용량 문서 느릴 수 있음 |
| PyPDF2       | 저수준 조작           | 병합/분할 빠름      | 표 인식 거의 없음        |
| pdfminer.six | 상세 로우데이터       | 폰트/좌표 완전 제어 | 복잡                     |
| Camelot      | 표 특화               | 격자 표 강력        | 텍스트 추출 약함         |
| Tesseract    | OCR 엔진              | 스캔 PDF 가능       | 느리고 오타 발생         |

---

# 13. 결론

본 시스템은 다음 이유로 pdfplumber를 채택하였습니다.

1. 이력서의 대부분은 표 기반
2. 좌표 기반 매칭 가능
3. 항목-값 매칭 정확도 우수
4. 상태 전환 기반 구조화 가능

단, 스캔 PDF 대응 시에는 OCR 엔진(Tesseract)와의 하이브리드 구성이 필요합니다.

---

# 🔥 최종 결과 예시 (전체 출력)

```json
{
  "header": {
    "name": "홍길동",
    "target_company": "삼성전자",
    "target_role": "백엔드 개발"
  },
  "education": [
    {
      "period": "2020.03~2024.02",
      "school_name": "서울대학교",
      "major": "컴퓨터공학과",
      "gpa": "3.8/4.5"
    }
  ],
  "activities": [],
  "awards": [],
  "projects": [],
  "certifications": [],
  "self_intro": []
}
```

---

# 📌 종합 평가

본 코드는 단순 텍스트 추출이 아닌,

* 객체 기반 분석
* 표 구조 인식
* 상태 머신 기반 분류
* 정규식 보강 로직
* 예외 대응 처리

까지 포함한 **준-프로덕션 수준 이력서 파싱 엔진**입니다.

---

원하시면 다음 단계로

* 아키텍처 다이어그램 제작
* 성능 최적화 포인트 분석
* 예외 케이스 대응 전략
* 면접 발표용 5분 요약 스크립트

까지 만들어 드리겠습니다.
