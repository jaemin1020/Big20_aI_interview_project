# 🥉 3순위 문제 분석: "은행 창구가 꽉 막혔어요!" (DB 트랜잭션 충돌 및 누수)

안녕! 이번에는 우리 시스템의 저장 창고인 **데이터베이스(DB)**에서 왜 자꾸 "경고!" 메시지가 뜨는지 아주 쉽게 설명해줄게. 🏦

---

## 1. 지금 무슨 일이 벌어지고 있나요? (문제 상황)

우리 시스템이 지원자의 자소서를 읽거나(RAG 검색), 점수를 저장할 때 가끔 이런 로그가 찍혀.
*   **로그 기록:** `WARNING: there is already a transaction in progress`
*   **의미:** "이미 업무 처리 중인데, 똑같은 창구에서 또 다른 일을 하려고 하네요!"

이게 반복되면 은행 창구(DB 연결)가 하나도 남지 않게 되고, 결국 시스템 전체가 멈춰버리는 **'데이터베이스 셧다운'** 위험이 있어.

---

## 2. 왜 이런 문제가 생길까요? (오류 분석)

범인은 **'일을 끝냈는데 퇴근 안 하는 직원'** 때문이야.

### 🚩 범인은 '닫히지 않는 세션(Session)'
우리가 DB에서 데이터를 가져오거나 저장할 때는 '세션'이라는 창구를 열어. 일을 다 했으면 "다 했어요!" 하고 창구를 닫고 나와야 다음 사람이 쓸 수 있거든.

그런데 지금 코드를 보면:
1.  **자소서 검색 시:** LangChain이라는 도구가 DB 창구를 열어서 데이터를 찾는데, 다 찾고 나서 창구를 제대로 안 닫고 그냥 가버리는 경우가 있어.
2.  **직원들의 실수:** "창구 열기 -> 데이터 찾기 -> (실수로 닫기 생략) -> 끝!" 이런 식으로 코드가 짜여 있으면, 창구는 계속 '사용 중'인 상태로 남게 돼.

결국 창구는 10개뿐인데, 일을 안 하는 창구들이 계속 자리를 차지하고 있어서 새로 온 손님들이 일을 못 보게 되는 거지. 이를 전문 용어로 **'세션 누수(Session Leak)'**라고 불러.

---

## 3. 어떻게 고칠 건가요? (해결 방안)

우리는 **'자동 문닫기'** 장치를 모든 창구에 설치할 거야.

### ✅ 해결책 1: `with` 문법 (자동 문닫기) 엄격 적용
파이썬에는 `with`라는 마법의 문장이 있어. 이 안에 코드를 넣으면, 일이 끝나든 에러가 나든 **무조건 창구를 닫고 나오게** 보장해줘.
*   **수정 방향:** `with Session(engine) as session:` 패턴을 모든 DB 작업에 적용할 거야.

### ✅ 해결책 2: `finally` 블록 (마지막 확인)
혹시라도 아주 큰 사고(에러)가 나서 코드가 중간에 멈추더라도, "마지막으로 문은 꼭 닫으렴!"이라고 알려주는 `finally` 장치를 추가할 거야.

### ✅ 해결책 3: LangChain DB 연결 관리 강화
자소서를 찾을 때 쓰는 도구가 DB를 마음대로 열고 닫지 못하게, 우리가 만든 안전한 창구 관리자를 통해서만 DB에 접근하게 만들 거야.

---

## 🚀 고치고 나면 뭐가 좋아지나요?

- **DB가 튼튼해져요:** 창구가 부족해서 버벅거리는 일이 사라져요.
- **사고가 안 나요:** 갑자기 서버가 멈추거나 데이터가 꼬이는 위험이 줄어들어요.
- **속도가 일정해요:** 창구 관리가 잘 되니까 언제든 빠르게 데이터를 넣고 뺄 수 있어요!

이제 창구마다 자동 문닫기 장치를 달아주었어! 아래에서 구체적으로 어떻게 고쳤는지 확인해봐. 🛠️

---

## 🛠️ 실제 어떻게 고쳤나요? (코드 수정 내역)

가장 큰 원인이었던 **'RAG 검색 엔진(자소서 검색)'**의 연결 방식을 아주 튼튼하게 바꿨어.

### 1. RAG 엔진 연결 최적화 (rag_retrieval.py): "창구 관리자를 한 명으로 통일하기"
기존에는 자소서를 검색할 때마다 "나는 이 주소로 DB에 접속할래!"라며 각자 새로운 연결을 시도했어. 그러다 보니 이미 일을 하고 있는데 또 일을 시키는 충돌이 발생했지. 

이제는 우리 시스템의 공식 창구 관리자(SQLAlchemy Engine)를 공동으로 사용하도록 바꿨어.

```python
# [수정 전: 각자 알아서 접속]
_vector_stores[name] = PGVector(
    connection_string=DATABASE_URL, # "나는 내 갈 길 간다!"
    ...
)

# [수정 후: 공식 창구 관리자를 통해 접속]
from db import engine # 우리 집 공식 창구 관리자 호출
_vector_stores[name] = PGVector(
    connection=engine, # "관리자님, 창구 하나만 빌려주세요!"
    ...
)
```

이렇게 하면 `engine`이 알아서 "지금은 이 창구가 비어있으니 여기로 가세요"라고 교통정리를 해주기 때문에 **'트랜잭션 충돌'**이나 **'창구 부족'** 현상이 완벽하게 해결돼.

---

## 🏁 결과 확인 (이제 이렇게 변해요!)

1.  **DB 경고 메시지가 사라져요.** (`already a transaction...` 에러 해결)
2.  **시스템이 훨씬 튼튼해져요.** (세션 누수가 없어 대용량 처리도 문제없음)
3.  **검색 속도가 안정화돼요.** (매번 새로 접속할 필요 없이 이미 열린 창구를 알뜰하게 재사용함)

이제 우리 AI 면접관의 저장 창고도 아주 깨끗하고 튼튼하게 정리됐어! 고생 많았어! 🚀
