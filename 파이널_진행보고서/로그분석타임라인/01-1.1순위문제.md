# 🥇 1순위 문제 분석: "똑같은 숙제를 왜 자꾸 시켜요?" (TTS 중복 처리 현상)

안녕! 지금 우리 AI 면접관 시스템에서 가장 먼저 고쳐야 할 '1순위 문제'가 무엇인지, 왜 발생하는지 중학생 친구도 이해할 수 있게 아주 쉽게 설명해줄게. 👨‍딩동댕!

---

## 1. 지금 무슨 일이 벌어지고 있나요? (문제 상황)

쉽게 비유를 들어볼게. **선생님(백엔드)**과 **학생(AI 워커)**, 그리고 **질문쟁이 반장(프론트엔드)**이 있어.

1.  **반장:** "선생님! 1번 질문 녹음 파일 다 됐나요?"
2.  **선생님:** "잠시만... 서랍(파일 폴더)에 없네? **학생아! 1번 질문 녹음해와!**"
3.  **반장 (1초 뒤):** "선생님! 1번 질문 녹음 파일 다 됐나요?"
4.  **선생님:** "어... 아직 서랍에 없는데? **학생아! 1번 질문 녹음해와!** (또 시킴)"
5.  **반장 (또 1초 뒤):** "선생님! 1번 질문 녹음 파일 다 됐나요?"
6.  **선생님:** "아직도 없네? **학생아! 1번 질문 녹음해와!** (계속 시킴)"

파일이 만들어지는 데는 보통 5초 정도 걸리는데, 반장은 1초마다 물어봐. 선생님은 파일이 아직 안 나왔으니까 그때마다 학생한테 **"똑같은 녹음 또 해와!"**라고 계속 시키고 있는 거야.

결국 학생은 똑같은 1번 질문 녹음을 5번이나 하고 있고, 컴퓨터는 **"나 너무 힘들어!"**라며 땀을 뻘뻘 흘리고 (CPU 100%) 있는 상태야.

---

## 2. 왜 이런 바보 같은 짓을 할까요? (오류 분석)

분명히 코드에는 **"이미 시켰으면 또 시키지 마!"**라는 **자물쇠(Redis 락)** 장치가 있긴 해. 그런데 이 자물쇠가 너무 부실해.

### 🚩 범인은 '찰나의 순간' (Race Condition)
현재 컴퓨터의 논리는 이래:
- "자물쇠가 있나 확인해봐" -> "없네?" -> "그럼 질문을 시키고 **자물쇠를 채워!**"

그런데 컴퓨터는 너무 빨라서, 자물쇠가 없다는 걸 확인하고 실제 자물쇠를 채우기까지 **0.0001초**라는 아주 짧은 시간이 걸려. 반장이 그 찰나에 또 물어보면, 컴퓨터는 **"어? 아직 자물쇠 없는데? 또 시켜야지!"**라고 착각해버리는 거야. 

이걸 전문 용어로 **'체크-앤-셋(Check-then-Set)'** 오류라고 해. 확인하고 행동하는 사이에 틈이 생기는 거지!

---

## 3. 어떻게 고칠 건가요? (해결 방안)

우리는 이 부실한 자물쇠를 **'마법의 단일 열쇠'**로 바꿀 거야.

### ✅ 해결책 1: Redis의 SET NX (원자적 락) 사용
확인하고 자물쇠를 채우는 게 아니라, **"자물쇠가 없을 때만 한꺼번에 채워!"**라는 명령을 쓸 거야.
- 자물쇠가 이미 있으면 명령 자체가 실패하고, 없으면 단 0.0001초의 틈도 주지 않고 즉시 채워버려. 
- 이렇게 하면 아무리 반장이 1초에 백 번을 물어봐도, 딱 한 명의 학생만 녹음을 시작하게 돼.

### ✅ 해결책 2: 학생(AI 워커)의 이중 확인
학생도 녹음기를 켜기 직전에 **"어? 나 말고 다른 친구가 이미 녹음해서 서랍에 넣어두지 않았나?"**라고 한 번 더 확인하게 만들 거야. 그럼 이미 파일이 만들어졌을 때는 연산을 아예 안 하고 바로 쉴 수 있지!

### ✅ 해결책 3: 불필요한 일꾼 부르지 않기
지금은 선생님이 매번 새로운 일꾼(Thread)을 불러서 학생한테 연락하게 하는데, 이것도 자원을 낭비해. 자물쇠가 채워져 있다면 아예 일꾼을 부르지도 않도록 꼼꼼하게 막을 거야.

---

## 🚀 고치고 나면 뭐가 좋아지나요?

- **서버가 시원해져요:** 똑같은 일을 여러 번 안 하니까 컴퓨터가 쌩쌩하게 돌아가요.
- **사람이 많아져도 끄떡없어요:** 면접 보는 사람이 100명이 되어도 서버가 다운되지 않아요.
- **돈이 절약돼요:** 불필요한 계산을 안 하니까 전기세(클라우드 비용)도 덜 나와요!

이제 분석은 끝났어! 이 내용을 바탕으로 더 튼튼한 자물쇠를 달았어. 아래에서 우리가 어떻게 고쳤는지 확인해봐! 📝

---

## 🛠️ 실제 어떻게 고쳤나요? (코드 수정 내약)

우리는 크게 **백엔드(선생님)**와 **AI 워커(학생)** 두 곳을 모두 손봤어.

### 1. 백엔드 (interviews.py): "부실한 자물쇠를 일체형 자물쇠로!"
기존에는 "열려있나 확인하고, 채운다"라는 두 단계로 자물쇠를 채웠어. 이걸 **"없으면 바로 채워!"**라는 한 단계(SET NX)로 바꿨지.

```python
# [수정 전]
if redis_client.get(lock_key): return  # 1. 확인
redis_client.setex(lock_key, 60, "in_progress") # 2. 채우기 (이 사이에 틈이 생김!)

# [수정 후]
is_locked = redis_client.set(lock_key, "in_progress", ex=60, nx=True) # 한 번에!
if not is_locked: return # 이미 누가 채웠으면 바로 끝!
```

### 2. 백엔드 (interviews.py): "쓸데없는 일꾼 부르지 않기!"
반장이 물어볼 때마다 "가서 물어보고 와!"라고 일꾼(Thread)을 보냈는데, 이제는 가기 전에 **"어, 이미 자물쇠 잠겨있네? 일꾼 안 보내도 되겠다!"**라고 먼저 판단하게 했어.

### 3. AI 워커 (tts.py): "일하기 직전에 다시 한 번 확인!"
학생(워커)도 녹음기 전원을 켜기 바로 직전에, **"어라? 내가 딴짓하는 사이에 누가 벌써 파일 다 만들어서 넣어뒀나?"**라고 이중으로 확인해. 혹시라도 큐(Queue)에 똑같은 일이 두 개 들어와도 두 번째 아이는 바로 퇴근할 수 있지!

```python
# [AI 워커의 이중 방어 로직]
with tts_lock: # 일할 순서가 됐을 때
    if final_out.exists(): # "오잉? 이미 파일이 있네?"
        return {"status": "success"} # 그럼 난 쉰다!
```

---

## 🏁 결과 확인 (이제 이렇게 변해요!)

1.  **똑같은 질문은 딱 한 번만 녹음해요.** (자원 낭비 0%)
2.  **서버가 여유로워져요.** (CPU 과부하 해결)
3.  **로그가 깨끗해져요.** (똑같은 작업 완료 로그가 여러 번 뜨지 않음)

이제 우리 시스템은 훨씬 더 똑똑하고 안정적으로 변했어! 고생했어! 🚀
