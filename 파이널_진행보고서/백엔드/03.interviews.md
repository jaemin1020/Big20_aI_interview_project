# ğŸ½ï¸ Interview Router ì½”ë“œ ì™„ì „ í•´ë¶€

> **í•µì‹¬ ë¹„ìœ **: ì´ ì½”ë“œëŠ” **ì‹ë‹¹ í™€ ë§¤ë‹ˆì €**ì…ë‹ˆë‹¤.
> ì†ë‹˜(í”„ë¡ íŠ¸ì—”ë“œ)ì˜ ì£¼ë¬¸ì„ ë°›ì•„ â†’ ê¸°ë¡í•˜ê³  â†’ ì£¼ë°©(AI Worker)ì— ì „ë‹¬í•˜ëŠ” **ì§€íœ˜Â·ì¤‘ê³„ ì „ë‹´** ì½”ë“œì…ë‹ˆë‹¤.
> ì‹¤ì œ ë¬´ê±°ìš´ ìš”ë¦¬(AI ì§ˆë¬¸ìƒì„±, TTS, í‰ê°€ë¦¬í¬íŠ¸)ëŠ” ì ˆëŒ€ ì§ì ‘ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

---

## ğŸ—ºï¸ ì „ì²´ ì‹œìŠ¤í…œ ì§€ë„

```
[ì†ë‹˜] í”„ë¡ íŠ¸ì—”ë“œ (React ë“±)
        â”‚
        â”‚  HTTP ìš”ì²­ / WebSocket
        â–¼
[í™€ ë§¤ë‹ˆì €] ì´ íŒŒì¼ â€” FastAPI Router (interviews.py)
        â”‚
        â”œâ”€â”€ DB ì €ì¥/ì¡°íšŒ (PostgreSQL)   â† ì§ì ‘ ì²˜ë¦¬
        â”‚
        â””â”€â”€ ì‘ì—… ì§€ì‹œ (Celery íƒœìŠ¤í¬)  â† ë‚¨í•œí…Œ ì‹œí‚´
                â”‚
                â”œâ”€â”€ [CPU ì£¼ë°©] TTS ìŒì„± í•©ì„±
                â””â”€â”€ [GPU ì£¼ë°©] AI ì§ˆë¬¸ ìƒì„± / í‰ê°€ ë¦¬í¬íŠ¸
                        â–²
                [ì‹¤ì‹œê°„ ì¤‘ê³„] Redis Pub/Sub â†’ WebSocket
```

---

## ğŸ“¦ ì„í¬íŠ¸ ì„¹ì…˜ â€” ì£¼ë°© ë„êµ¬ ì¤€ë¹„

```python
from fastapi import APIRouter, Depends, HTTPException, status, WebSocket, WebSocketDisconnect
from sqlmodel import Session, select, text
from celery import Celery
from datetime import datetime, timezone, timedelta
```

| ë„êµ¬              | ì‹ë‹¹ ë¹„ìœ                                       | ì‹¤ì œ ì—­í•                               |
| ----------------- | ---------------------------------------------- | -------------------------------------- |
| `APIRouter`     | í™€ ë§¤ë‹ˆì €ì˜ êµ¬ì—­(ë‹´ë‹¹ í…Œì´ë¸”)                  | `/interviews`ë¡œ ì‹œì‘í•˜ëŠ” URL ê·¸ë£¹    |
| `Depends`       | ì†ë‹˜ì´ ì˜¤ë©´ ìë™ìœ¼ë¡œ í•˜ëŠ” ê²ƒ(ì˜ˆ: ë¬¼ ë¨¼ì € ì£¼ê¸°) | í•¨ìˆ˜ ì‹¤í–‰ ì „ ìë™ìœ¼ë¡œ ë¨¼ì € ì‹¤í–‰í•  í•¨ìˆ˜ |
| `HTTPException` | ì£¼ë¬¸ ê±°ì ˆ ìª½ì§€                                 | HTTP ì˜¤ë¥˜ ì‘ë‹µ ë°œìƒ                    |
| `WebSocket`     | ì£¼ë°©ê³¼ í™€ ì‚¬ì´ ì¸í„°í°                          | ì‹¤ì‹œê°„ ì–‘ë°©í–¥ í†µì‹                      |
| `Session`       | ì£¼ë°© ì£¼ë¬¸ì„œ ì—°ê²°                               | DB ì—°ê²° ì„¸ì…˜                           |
| `select`        | íŠ¹ì • ì¬ë£Œë¥¼ ì°½ê³ ì—ì„œ ì°¾ëŠ” í–‰ìœ„                 | SQL SELECT ì¿¼ë¦¬                        |
| `celery`        | ì£¼ë°© í˜¸ì¶œ ë²¨                                   | ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ ì‹œìŠ¤í…œ               |

---

## â° ì‹œê°„ ì„¤ì • â€” í•œêµ­ ì‹œê°„(KST)

```python
KST = timezone(timedelta(hours=9))

def get_kst_now():
    return datetime.now(KST).replace(tzinfo=None)
```

### ì—­í• 

- ëª¨ë“  DB ì €ì¥ ì‹œê°ì„ **í•œêµ­ í‘œì¤€ì‹œ(UTC+9)** ë¡œ ê¸°ë¡í•˜ëŠ” ìœ í‹¸ í•¨ìˆ˜
- `replace(tzinfo=None)` : DB ì €ì¥ ì‹œ ì‹œê°„ëŒ€ ì •ë³´ë¥¼ ì œê±°í•´ ì¶©ëŒ ë°©ì§€

### ì‚¬ìš© ì˜ˆ

```python
created_at = get_kst_now()  # 2026-02-19 14:30:00 (í•œêµ­ ì‹œê°„, ì‹œê°„ëŒ€ ì •ë³´ ì—†ìŒ)
```

---

## ğŸ”Œ WebSocket ì—”ë“œí¬ì¸íŠ¸ â€” ì‹¤ì‹œê°„ ì¸í„°í°

```python
@router.websocket("/ws/{interview_id}")
async def interview_stream_ws(websocket: WebSocket, interview_id: int):
```

### ì‹ë‹¹ ë¹„ìœ 

```
AI ì£¼ë°©ì´ ìš”ë¦¬(ì§ˆë¬¸)ë¥¼ ë§Œë“œëŠ” ê³¼ì •ì„
ì†ë‹˜ í…Œì´ë¸”ì— ì‹¤ì‹œê°„ìœ¼ë¡œ ì¤‘ê³„í•´ì£¼ëŠ” ì¸í„°í°
"ì§€ê¸ˆ ì§ˆë¬¸ ìƒì„± ì¤‘... ê±°ì˜ ë‹¤ ëì–´ìš”..." í† í° ë‹¨ìœ„ë¡œ ì „ì†¡
```

### ë™ì‘ íë¦„

```
1. í”„ë¡ íŠ¸ì—”ë“œê°€ WebSocket ì—°ê²° ìš”ì²­
        â”‚
2. Redis ì±„ë„ "interview_{id}_stream" êµ¬ë… ì‹œì‘
        â”‚
3. while True ë£¨í”„ ì‹œì‘
        â”‚
        â”œâ”€â”€ AI Workerê°€ Redisì— í† í° publish
        â”‚         â”‚
        â”œâ”€â”€ ì´ ì½”ë“œê°€ get_message()ë¡œ ìˆ˜ì‹ 
        â”‚         â”‚
        â””â”€â”€ websocket.send_json()ìœ¼ë¡œ í”„ë¡ íŠ¸ì— ì „ë‹¬
        â”‚
4. WebSocketDisconnect ë°œìƒ ì‹œ êµ¬ë… í•´ì œ & ì—°ê²° ì¢…ë£Œ
```

### ì½”ë“œ ìƒì„¸

```python
r = redis.from_url(REDIS_URL)      # Redis ì—°ê²°
pubsub = r.pubsub()                # Pub/Sub ê°ì²´ ìƒì„±
channel = f"interview_{interview_id}_stream"
await pubsub.subscribe(channel)    # ì±„ë„ êµ¬ë… ì‹œì‘

while True:
    # Redisì—ì„œ ë©”ì‹œì§€ í™•ì¸ (ìµœëŒ€ 1ì´ˆ ëŒ€ê¸°)
    message = await pubsub.get_message(ignore_subscribe_messages=True, timeout=1.0)
  
    if message:
        data = message['data']
        if isinstance(data, bytes):
            data = data.decode('utf-8')    # bytes â†’ ë¬¸ìì—´ ë³€í™˜
      
        # í”„ë¡ íŠ¸ì—”ë“œë¡œ ì „ì†¡
        await websocket.send_json({
            "type": "ai_token",
            "token": data
        })
  
    await asyncio.sleep(0.01)      # CPU ê³¼ë¶€í•˜ ë°©ì§€
```

### try/except/finally êµ¬ì¡°

```python
try:
    # ì •ìƒ ë™ì‘ (ë¬´í•œ ë£¨í”„)
except WebSocketDisconnect:
    # ì†ë‹˜ì´ ìë¦¬ë¥¼ ë– ë‚¨ â†’ ì •ìƒ ì¢…ë£Œ ì²˜ë¦¬
except Exception as e:
    # ì˜ˆê¸°ì¹˜ ëª»í•œ ì˜¤ë¥˜
finally:
    # ë¬´ì¡°ê±´ ì‹¤í–‰: ì±„ë„ êµ¬ë… í•´ì œ + Redis ì—°ê²° ë‹«ê¸°
    await pubsub.unsubscribe(channel)
    await r.close()
```

---

## ğŸ”Š TTS í—¬í¼ í•¨ìˆ˜ â€” ìŒì„± íŒŒì¼ ìƒì„± ìš”ì²­

```python
def _fire_tts_for_question(question_id: int, question_text: str) -> None:
```

### ì‹ë‹¹ ë¹„ìœ 

```
ì†ë‹˜ì´ ìš”ì²­í•œ ì§ˆë¬¸ì— ëŒ€í•´ ìŒì„±ì„ ë¯¸ë¦¬ ë§Œë“¤ì–´ë‹¬ë¼ê³ 
CPU ì£¼ë°©ì— ì£¼ë¬¸ì„œë¥¼ ë˜ì ¸ë†“ëŠ” í•¨ìˆ˜.
ì£¼ë°©ì´ ì™„ì„±í•  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë°”ë¡œ ë‹¤ìŒ ì—…ë¬´ë¡œ.
```

### ë™ì‘ íë¦„

```
1. íŒŒì¼ ê²½ë¡œ í™•ì¸ â†’ /app/uploads/tts/q_{id}.wav
        â”‚
2. íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬? â†’ ì¦‰ì‹œ return (ì¤‘ë³µ ìƒì„± ë°©ì§€)
        â”‚
3. [ë‹¨ê³„] íƒœê·¸ ì œê±°
   "[ê¸°ë³¸ ì§ˆë¬¸] ìê¸°ì†Œê°œ í•´ì£¼ì„¸ìš”" â†’ "ìê¸°ì†Œê°œ í•´ì£¼ì„¸ìš”"
        â”‚
4. celery_app.send_task("tasks.tts.synthesize", ..., queue="cpu_queue")
   â†’ CPU Workerì—ê²Œ íŒŒì¼ ìƒì„± ìš”ì²­ í›„ ì¦‰ì‹œ ë°˜í™˜
```

### íƒœê·¸ ì œê±° ë¡œì§

```python
if question_text.startswith('[') and ']' in question_text:
    parts = question_text.split(']', 1)
    # "[ê¸°ë³¸ ì§ˆë¬¸] ìê¸°ì†Œê°œ í•´ì£¼ì„¸ìš”".split(']', 1)
    # â†’ ['[ê¸°ë³¸ ì§ˆë¬¸', ' ìê¸°ì†Œê°œ í•´ì£¼ì„¸ìš”']
    clean_text = parts[1].strip()  # â†’ "ìê¸°ì†Œê°œ í•´ì£¼ì„¸ìš”"
```

### ì™œ `_`ë¡œ ì‹œì‘í•˜ëŠ”ê°€?

íŒŒì´ì¬ ê´€ë¡€ìƒ `_`ë¡œ ì‹œì‘í•˜ëŠ” í•¨ìˆ˜ëŠ” **"ë‚´ë¶€ ì „ìš©, ì™¸ë¶€ì—ì„œ ì§ì ‘ í˜¸ì¶œ ìì œ"** ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

---

## ğŸ†• ë©´ì ‘ ìƒì„± â€” í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸

```python
@router.post("", response_model=InterviewResponse)
async def create_interview(
    interview_data: InterviewCreate,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
```

### ì‹ë‹¹ ë¹„ìœ 

```
ì†ë‹˜ì´ "ë©´ì ‘ ì£¼ë¬¸"ì„ í•˜ë©´:
1. ì‹ ì› í™•ì¸ (current_user)
2. ì´ë ¥ì„œì—ì„œ ì§ë¬´Â·íšŒì‚¬ íŒŒì•…
3. ì£¼ë¬¸ì„œ(Interview) DBì— ê¸°ë¡
4. ê¸°ë³¸ ì§ˆë¬¸ 2ê°œ ì¦‰ì‹œ ìƒì„± (ìê¸°ì†Œê°œ, ì§€ì›ë™ê¸°)
5. AI ì£¼ë°©ì— "ëª¨ë¸ ì˜ˆì—´í•´!" ì§€ì‹œ
6. "ì ‘ìˆ˜ëìŠµë‹ˆë‹¤" ì‘ë‹µ ë°˜í™˜
```

### ì „ì²´ ë™ì‘ íë¦„ (ë‹¨ê³„ë³„)

```
[STEP 1] ì´ë ¥ì„œ íŒŒì‹±
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
resume = db.get(Resume, interview_data.resume_id)
s_data = json.loads(resume.structured_data)    # JSON íŒŒì‹±
target_role = s_data["header"]["target_role"]  # ì§ë¬´ ì¶”ì¶œ

[STEP 2] íšŒì‚¬ ìë™ ë§¤ì¹­
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
target_company_name = s_data["header"]["target_company"]
stmt = select(Company).where(func.lower(Company.company_name) == func.lower(stripped_name))
found_company = db.exec(stmt).first()          # ëŒ€ì†Œë¬¸ì ë¬´ì‹œ ê²€ìƒ‰
extracted_company_id = found_company.id

[STEP 3] Interview ë ˆì½”ë“œ ìƒì„±
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
new_interview = Interview(candidate_id=..., position=target_role, ...)
db.add(new_interview)
db.commit()       # DB ì €ì¥
db.refresh(new_interview)  # ID ê°±ì‹ 

[STEP 4] ì§ë¬´ ì „í™˜ ì—¬ë¶€ íŒë‹¨ â†’ ì‹œë‚˜ë¦¬ì˜¤ ì„ íƒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
is_transition = check_if_transition(major, target_role)
if is_transition:
    from config.interview_scenario_transition import get_initial_stages
else:
    from config.interview_scenario import get_initial_stages

[STEP 5] í…œí”Œë¦¿ ì§ˆë¬¸ 2ê°œ ìƒì„± (for ë£¨í”„)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for stage_config in initial_stages:
    question_text = generate_template_question(template, candidate_info)
    question = Question(content=question_text, ...)
    db.add(question)
    db.flush()  # question.id íšë“ (ì„ì‹œ ë°˜ì˜)
  
    celery_app.send_task("tasks.tts.synthesize", ...)  # TTS ìš”ì²­
  
    transcript = Transcript(interview_id=..., speaker="AI", ...)
    db.add(transcript)

[STEP 6] í•œêº¼ë²ˆì— DB ì»¤ë°‹
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
new_interview.status = InterviewStatus.LIVE
db.commit()   # ëª¨ë“  ì§ˆë¬¸Â·ëŒ€í™” ì €ì¥

[STEP 7] AI ëª¨ë¸ ì‚¬ì „ ë¡œë”© ìš”ì²­ (fire-and-forget)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
celery_app.send_task("tasks.question_generation.preload_model", queue="gpu_queue")

[STEP 8] ì‘ë‹µ ë°˜í™˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
return InterviewResponse(id=..., status=..., ...)
```

### JSON ì´ì¤‘ ì¸ì½”ë”© ë°©ì–´ ë¡œì§

```python
# DBì—ì„œ JSONì´ ë¬¸ìì—´ë¡œ ì˜¬ ë•Œ ëŒ€ë¹„
if isinstance(s_data, str):
    s_data = json.loads(s_data)   # 1ì°¨ íŒŒì‹±
    if isinstance(s_data, str):   # ê·¸ë˜ë„ ë¬¸ìì—´ì´ë©´?
        s_data = json.loads(s_data)  # 2ì°¨ íŒŒì‹± (ì´ì¤‘ ì¸ì½”ë”© ëŒ€ì‘)
```

---

## ğŸ“‹ ì¸í„°ë·° ëª©ë¡ ì¡°íšŒ

```python
@router.get("")
async def get_all_interviews(
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
```

### ì‹ë‹¹ ë¹„ìœ 

```
- ì¼ë°˜ ì†ë‹˜: ìê¸° ì£¼ë¬¸ ë‚´ì—­ë§Œ ë³¼ ìˆ˜ ìˆìŒ
- ë§¤ë‹ˆì €/ê´€ë¦¬ì(recruiter, admin): ì „ì²´ ì£¼ë¬¸ ë‚´ì—­ ì—´ëŒ ê°€ëŠ¥
```

### ê¶Œí•œ ë¶„ê¸°

```python
if current_user.role not in ["recruiter", "admin"]:
    # ì¼ë°˜ ì‚¬ìš©ì: ë³¸ì¸ ë©´ì ‘ë§Œ
    stmt = select(Interview).where(Interview.candidate_id == current_user.id)
else:
    # ë¦¬í¬ë£¨í„°/ê´€ë¦¬ì: ì „ì²´ ë©´ì ‘
    stmt = select(Interview)
```

### ì‘ë‹µ ê°€ê³µ

```python
result = []
for interview in interviews:
    candidate = db.get(User, interview.candidate_id)
    resume = db.get(Resume, interview.resume_id)
    company = db.get(Company, interview.company_id)

    # íšŒì‚¬ëª… ìš°ì„ ìˆœìœ„: ì´ë ¥ì„œ â†’ DB íšŒì‚¬ í…Œì´ë¸” â†’ ê¸°ë³¸ê°’
    actual_company = "ì§€ì› ê¸°ì—…"
    if resume and resume.structured_data:
        actual_company = resume.structured_data.get("header", {}).get("target_company") or actual_company
    if (not actual_company or actual_company == "ì§€ì› ê¸°ì—…") and company:
        actual_company = company.company_name

    result.append({...})

return result
```

---

## â“ ë©´ì ‘ ì§ˆë¬¸ ëª©ë¡ ì¡°íšŒ

```python
@router.get("/{interview_id}/questions")
async def get_interview_questions(
    interview_id: int,
    db: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
```

### ì‹ë‹¹ ë¹„ìœ 

```
"ì´ í…Œì´ë¸”ì— ë‚˜ê°„ ìš”ë¦¬ ëª©ë¡ì´ ë­ì•¼?"
+ ê° ìš”ë¦¬ë§ˆë‹¤ ìŒì„± ì•ˆë‚´(TTS) íŒŒì¼ URLë„ í•¨ê»˜ ì œê³µ
```

### í•µì‹¬ ë‚´ë¶€ í•¨ìˆ˜: `get_audio_url()`

```python
def get_audio_url(question_id: int, question_text: str) -> str | None:
    filepath = TTS_UPLOAD_DIR / f"q_{question_id}.wav"
  
    if filepath.exists():
        # íŒŒì¼ ìˆìŒ â†’ URL ë°˜í™˜
        timestamp = int(get_kst_now().timestamp())  # ìºì‹œ ë°©ì§€ìš© íƒ€ì„ìŠ¤íƒ¬í”„
        return f"{BACKEND_PUBLIC_URL}/uploads/tts/q_{question_id}.wav?t={timestamp}"
  
    # íŒŒì¼ ì—†ìŒ â†’ ë°±ê·¸ë¼ìš´ë“œì—ì„œ TTS ìƒì„± ìš”ì²­ í›„ None ë°˜í™˜
    threading.Thread(
        target=_fire_tts_for_question,
        args=(question_id, question_text),
        daemon=True
    ).start()
    return None
```

### ë¦¬ìŠ¤íŠ¸ ì»´í”„ë¦¬í—¨ì…˜ìœ¼ë¡œ ì‘ë‹µ êµ¬ì„±

```python
return {
    "status": interview.status,
    "questions": [
        {
            "id": t.question_id,
            "content": t.text,
            "order": t.order,
            "audio_url": get_audio_url(t.question_id, t.text)  # ìˆìœ¼ë©´ URL, ì—†ìœ¼ë©´ None
        }
        for t in results   # Transcript ëª©ë¡ì„ ìˆœíšŒí•˜ë©° ë”•ì…”ë„ˆë¦¬ ìƒì„±
    ]
}
```

---

## ğŸ’¬ ì „ì²´ ëŒ€í™” ê¸°ë¡ ì¡°íšŒ

```python
@router.get("/{interview_id}/transcripts")
async def get_interview_transcripts(...)
```

### ì‹ë‹¹ ë¹„ìœ 

```
ê·¸ í…Œì´ë¸”ì—ì„œ ì˜¤ê°„ ëª¨ë“  ëŒ€í™”(AI ì§ˆë¬¸ + ì§€ì›ì ë‹µë³€) ì „ì²´ ê¸°ë¡ ì¡°íšŒ
AI, User ë°œí™” êµ¬ë¶„ ì—†ì´ ì‹œê°„ìˆœ ì •ë ¬
```

```python
stmt = select(Transcript).where(
    Transcript.interview_id == interview_id
).order_by(Transcript.timestamp)   # ì‹œê°„ìˆœ ì •ë ¬
```

---

## âœ… ë©´ì ‘ ì™„ë£Œ ì²˜ë¦¬

```python
@router.post("/{interview_id}/complete")
async def complete_interview(...)
```

### ì‹ë‹¹ ë¹„ìœ 

```
"ì´ í…Œì´ë¸” ì‹ì‚¬ ëë‚¬ìŠµë‹ˆë‹¤!"
â†’ ìƒíƒœ COMPLETEDë¡œ ë³€ê²½
â†’ GPU ì£¼ë°©ì— "ìµœì¢… í‰ê°€ì„œ ë§Œë“¤ì–´!" ì§€ì‹œ í›„ ì¦‰ì‹œ ë°˜í™˜
```

```python
interview.status = InterviewStatus.COMPLETED
interview.end_time = get_kst_now()
db.add(interview)
db.commit()

# GPU Workerì—ê²Œ í‰ê°€ ë¦¬í¬íŠ¸ ìƒì„± ì§€ì‹œ (ê²°ê³¼ ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŒ!)
celery_app.send_task(
    "tasks.evaluator.generate_final_report",
    args=[interview_id],
    queue='gpu_queue'
)

return {"status": "completed", "interview_id": interview_id}  # ì¦‰ì‹œ ë°˜í™˜
```

---

## ğŸ“Š í–‰ë™ ë¶„ì„ ì ìˆ˜ ì €ì¥

```python
@router.patch("/{interview_id}/behavior-scores")
async def save_behavior_scores(interview_id: int, request: dict, db: Session = ...)
```

### ì‹ë‹¹ ë¹„ìœ 

```
ë©´ì ‘ ì˜ìƒì„ ë¶„ì„í•œ ì™¸ë¶€ ì¹´ë©”ë¼ ì‹œìŠ¤í…œ(media-server)ì´
"í‘œì •Â·í–‰ë™ ì ìˆ˜ ë‹¤ ë‚˜ì™”ì–´ìš”" í•˜ê³  ê²°ê³¼ë¥¼ ì „ë‹¬í•´ì£¼ë©´
DBì— ê¸°ë¡í•˜ëŠ” ì ‘ìˆ˜ì°½êµ¬
```

### ì €ì¥ ëŒ€ìƒ 2ê°€ì§€

```python
# â‘  interviews í…Œì´ë¸”: ë©´ì ‘ ì „ì²´ í‰ê·  ì ìˆ˜
averages = request.get("averages", {})
interview.emotion_summary = {
    "averages": averages,
    "interview_duration_sec": ...,
    "total_questions": ...
}
interview.overall_score = averages.get("total")

# â‘¡ transcripts í…Œì´ë¸”: ì§ˆë¬¸ë³„ ìƒì„¸ ì ìˆ˜
per_question = request.get("per_question", [])
for i, q_score in enumerate(per_question):
    if i < len(user_transcripts):
        user_transcripts[i].emotion = json.dumps(q_score)    # JSON ë¬¸ìì—´ë¡œ ì €ì¥
        user_transcripts[i].sentiment_score = q_score.get("total")
```

---

## ğŸ“„ í‰ê°€ ë¦¬í¬íŠ¸ ì¡°íšŒ

```python
@router.get("/{interview_id}/report", response_model=EvaluationReportResponse)
async def get_evaluation_report(...)
```

### ì‹ë‹¹ ë¹„ìœ 

```
ì†ë‹˜ì´ "ì˜¤ëŠ˜ ë©´ì ‘ ê²°ê³¼ì„œ ì£¼ì„¸ìš”" ìš”ì²­ ì‹œ
â†’ GPU ì£¼ë°©ì´ ì•„ì§ ì‘ì„± ì¤‘ì´ë©´? "ì ì‹œë§Œìš”~" (ì„ì‹œ ì‘ë‹µ)
â†’ ì™„ì„±ëìœ¼ë©´? ì „ì²´ ë¦¬í¬íŠ¸ ë°˜í™˜
```

### ë¦¬í¬íŠ¸ ì—†ì„ ë•Œ ì„ì‹œ ì‘ë‹µ

```python
if not report:
    return {
        "id": 0,
        "summary_text": "AIê°€ í˜„ì¬ ë©´ì ‘ ë‚´ìš©ì„ ìƒì„¸ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ ì£¼ì„¸ìš”.",
        "technical_feedback": "ë¶„ì„ì´ ì™„ë£Œë˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.",
        # ... ë‚˜ë¨¸ì§€ í•„ë“œ ê¸°ë³¸ê°’
    }
```

### Pydantic ë²„ì „ í˜¸í™˜ ì²˜ë¦¬

```python
try:
    report_dict = report.model_dump()   # Pydantic v2 (ìµœì‹ )
except AttributeError:
    report_dict = report.dict()          # Pydantic v1 (êµ¬ë²„ì „ ëŒ€ë¹„)
```

### `or` ì²´ì´ë‹ìœ¼ë¡œ í´ë°± ê°’ ì²˜ë¦¬

```python
# detailsì— ê°’ì´ ìˆìœ¼ë©´ ê·¸ê±¸ ì“°ê³ ,
# ì—†ìœ¼ë©´ summary_text ì“°ê³ ,
# ê·¸ê²ƒë„ ì—†ìœ¼ë©´ ê¸°ë³¸ ë¬¸êµ¬ ì‚¬ìš©
report_dict["technical_feedback"] = (
    details.get("technical_feedback") or
    report.summary_text or
    "ê¸°ìˆ  ì—­ëŸ‰ ë¶„ì„ ê²°ê³¼ê°€ ìƒì„± ì¤‘ì…ë‹ˆë‹¤."
)
```

---

## ğŸ”„ ì‹¤ì‹œê°„ ë©´ì ‘ ìƒì„± (Realtime ë²„ì „)

```python
@router.post("/realtime", response_model=InterviewResponse)
async def create_realtime_interview(...)
```

### `create_interview`ì™€ì˜ ì°¨ì´ì 

| í•­ëª©      | `create_interview` | `create_realtime_interview`             |
| --------- | -------------------- | ----------------------------------------- |
| ì´ˆê¸° ìƒíƒœ | `SCHEDULED`        | `IN_PROGRESS`                           |
| ëª©ì       | ì¼ë°˜ ì˜ˆì•½ ë©´ì ‘       | ì¦‰ì‹œ ì‹œì‘ ë©´ì ‘                            |
| ì‹œë‚˜ë¦¬ì˜¤  | ë™ì¼                 | ë™ì¼                                      |
| í´ë°± ì²˜ë¦¬ | ì—†ìŒ                 | `ImportError` ë°œìƒ ì‹œ í•˜ë“œì½”ë”© ê¸°ë³¸ì§ˆë¬¸ |

### í´ë°±(Fallback) ì²˜ë¦¬

```python
except ImportError:
    logger.warning("âš ï¸ Could not import interview_scenario, using hardcoded fallback")
    initial_stages = [
        {
            "stage": "intro",
            "template": "{candidate_name} ì§€ì›ìë‹˜, ê°„ë‹¨íˆ ìê¸°ì†Œê°œ ë¶€íƒë“œë¦½ë‹ˆë‹¤.",
            "order": 1
        },
        ...
    ]
```

---

## ğŸ”‘ í•µì‹¬ íŒ¨í„´ ì •ë¦¬

### 1. Fire-and-Forget (ì˜ê³  ìŠê¸°)

```python
# ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ì¦‰ì‹œ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ëŠ” íŒ¨í„´
celery_app.send_task("tasks.tts.synthesize", ...)
# â†‘ ì´ ì¤„ ì‹¤í–‰ í›„ TTS ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•ŠìŒ
logger.info("ë‹¤ìŒ ì‘ì—…ìœ¼ë¡œ...")   # ë°”ë¡œ ì‹¤í–‰ë¨
```

### 2. DB flush vs commit

```python
db.add(question)
db.flush()     # IDë§Œ ì„ì‹œ íšë“ (ì•„ì§ DB ë¯¸ì €ì¥, ë¡¤ë°± ê°€ëŠ¥)
# question.id ì‚¬ìš© ê°€ëŠ¥

# ëª¨ë“  ì‘ì—… ì™„ë£Œ í›„
db.commit()    # ì‹¤ì œ DBì— í•œêº¼ë²ˆì— ì €ì¥ (ì„±ëŠ¥ ìµœì í™”)
```

### 3. ê¶Œí•œ ê¸°ë°˜ ë¶„ê¸°

```python
if current_user.role not in ["recruiter", "admin"]:
    # ì¼ë°˜ ì‚¬ìš©ì â†’ ë³¸ì¸ ë°ì´í„°ë§Œ
else:
    # ê´€ë¦¬ì â†’ ì „ì²´ ë°ì´í„°
```

### 4. or ì²´ì´ë‹ í´ë°±

```python
# ìš°ì„ ìˆœìœ„: A â†’ B â†’ C ìˆœì„œë¡œ ì²« ë²ˆì§¸ "ì°¸ì¸ ê°’" ë°˜í™˜
value = A or B or C
```

---

## ğŸ“ ì „ì²´ ì—”ë“œí¬ì¸íŠ¸ ìš”ì•½í‘œ

| HTTP ë©”ì„œë“œ   | URL                       | í•¨ìˆ˜ëª…                        | ì§ì ‘ì²˜ë¦¬         | ìœ„ì„ì²˜ë¦¬           |
| ------------- | ------------------------- | ----------------------------- | ---------------- | ------------------ |
| `WebSocket` | `/ws/{id}`              | `interview_stream_ws`       | Redis êµ¬ë…Â·ì¤‘ê³„ | â€”                 |
| `POST`      | `/interviews`           | `create_interview`          | DB ì €ì¥          | TTS, ëª¨ë¸ ì˜ˆì—´     |
| `GET`       | `/interviews`           | `get_all_interviews`        | DB ì¡°íšŒ          | â€”                 |
| `GET`       | `/{id}/questions`       | `get_interview_questions`   | DB ì¡°íšŒ          | TTS (íŒŒì¼ ì—†ì„ ë•Œ) |
| `GET`       | `/{id}/transcripts`     | `get_interview_transcripts` | DB ì¡°íšŒ          | â€”                 |
| `POST`      | `/{id}/complete`        | `complete_interview`        | DB ì—…ë°ì´íŠ¸      | í‰ê°€ ë¦¬í¬íŠ¸ ìƒì„±   |
| `PATCH`     | `/{id}/behavior-scores` | `save_behavior_scores`      | DB ì €ì¥          | â€”                 |
| `GET`       | `/{id}/report`          | `get_evaluation_report`     | DB ì¡°íšŒÂ·ê°€ê³µ    | â€”                 |
| `POST`      | `/realtime`             | `create_realtime_interview` | DB ì €ì¥          | TTS                |

---

## ğŸ¯ ìµœì¢… ê²°ë¡ 

```
ì´ íŒŒì¼ì´ ì§ì ‘ í•˜ëŠ” ì¼        â”‚  ì´ íŒŒì¼ì´ ë‚¨í•œí…Œ ì‹œí‚¤ëŠ” ì¼
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… HTTP ìš”ì²­ ìˆ˜ì‹               â”‚  ğŸ”Š TTS ìŒì„± í•©ì„± (CPU Worker)
âœ… ì¸ì¦/ê¶Œí•œ í™•ì¸              â”‚  ğŸ¤– AI ì§ˆë¬¸ ìƒì„± (GPU Worker)
âœ… DB ì €ì¥ / ì¡°íšŒ              â”‚  ğŸ“Š í‰ê°€ ë¦¬í¬íŠ¸ ìƒì„± (GPU Worker)
âœ… ë°ì´í„° ê°€ê³µÂ·ì‘ë‹µ êµ¬ì„±       â”‚  ğŸ”¥ ëª¨ë¸ ì‚¬ì „ ë¡œë”© (GPU Worker)
âœ… Redis Pub/Sub ì¤‘ê³„          â”‚
âœ… ì—ëŸ¬ ì²˜ë¦¬ ë° í´ë°±            â”‚
```

> **ì´ ì½”ë“œì˜ ì¡´ì¬ ì´ìœ **: ë¬´ê±°ìš´ AI ì‘ì—…ì„ ë°±ê·¸ë¼ìš´ë“œë¡œ ìœ„ì„í•˜ì—¬
> ì‚¬ìš©ìì—ê²Œ **í•­ìƒ ì¦‰ê°ì ì¸ ì‘ë‹µ**ì„ ëŒë ¤ì£¼ëŠ” **ë¹„ë™ê¸° ì§€íœ˜ ê³„ì¸µ**ì…ë‹ˆë‹¤.
>
