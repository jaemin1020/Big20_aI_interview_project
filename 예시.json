[
  {
    "질문": "운영체제 커널 분석을 수행해 본 적이 있나? 있다면 어떤 부분을 중점적으로 보았는가?",
    "답변": "네, 주로 리눅스 커널의 시스템 콜 인터페이스와 프로세스 스케줄링 파트를 분석했습니다. 특히 시스템 콜이 발생했을 때 유저 모드에서 커널 모드로의 컨텍스트 스위칭 과정과 레지스터 저장 방식을 소스 코드 수준에서 추적하며 성능 오버헤드를 파악한 경험이 있습니다."
  },
  {
    "질문": "커널 수준에서 컨텍스트 스위칭(Context Switching)이 일어날 때 발생하는 부하의 주된 원인은 무엇인가?",
    "답변": "가장 큰 원인은 CPU 레지스터 상태의 저장 및 복구, 그리고 TLB(Translation Lookaside Buffer) 캐시 플러시로 인한 캐시 미스 발생입니다. 커널이 현재 실행 중인 프로세스의 TCB를 업데이트하고 다음 프로세스의 스택 포인터를 교체하는 과정에서 수반되는 메모리 접근 지연이 전체 성능에 영향을 미칩니다."
  },
  {
    "질문": "가상 메모리 시스템에서 페이징(Paging)을 사용할 때 커널이 페이지 폴트(Page Fault)를 처리하는 과정을 설명하라.",
    "답변": "CPU가 MMU를 통해 주소 변환을 시도하다가 유효하지 않은 페이지에 접근하면 트랩이 발생합니다. 커널의 페이지 폴트 핸들러가 호출되며, 해당 주소가 유효한지 확인 후 디스크에서 메모리로 페이지를 로드합니다. 이후 페이지 테이블을 업데이트하고 원인 문장을 재실행합니다."
  },
  {
    "질문": "커널 모드에서 스핀락(Spinlock)과 뮤텍스(Mutex)의 차이점과 사용 환경에 대해 설명하라.",
    "답변": "스핀락은 락을 획득할 때까지 CPU를 점유하며 대기하는 방식으로 컨텍스트 스위칭이 없으므로 임계 구역이 매우 짧을 때 유리합니다. 반면 뮤텍스는 락을 얻지 못하면 프로세스를 대기 상태로 전환시켜 CPU를 양보하므로, I/O 작업 등 대기 시간이 길어질 때 적합합니다."
  }
]